"use strict";(self.webpackChunkmohan_doc=self.webpackChunkmohan_doc||[]).push([[1320],{2169:e=>{e.exports=JSON.parse('{"permalink":"/mohan-doc/blog/telegram-archive-all-in","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/telegram-archive-all-in.md","source":"@site/blog/telegram-archive-all-in.md","title":"Telegram Archive \u2013 Schriften Channel","description":"All posts from my Schriften Telegram channel in one place.","date":"2025-06-08T00:00:00.000Z","tags":[{"inline":true,"label":"telegram","permalink":"/mohan-doc/blog/tags/telegram"},{"inline":true,"label":"archive","permalink":"/mohan-doc/blog/tags/archive"},{"inline":true,"label":"import","permalink":"/mohan-doc/blog/tags/import"}],"readingTime":92.34,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Telegram Archive \u2013 Schriften Channel","tags":["telegram","archive","import"],"date":"2025-06-08T00:00:00.000Z","description":"All posts from my Schriften Telegram channel in one place."},"unlisted":false,"nextItem":{"title":"Welcome","permalink":"/mohan-doc/blog/welcome"}}')},8232:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var a=t(2169),o=t(4848),i=t(8453);const s={title:"Telegram Archive \u2013 Schriften Channel",tags:["telegram","archive","import"],date:new Date("2025-06-08T00:00:00.000Z"),description:"All posts from my Schriften Telegram channel in one place."},r=void 0,c={authorsImageUrls:[]},l=[];function d(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'NextJs tips 12:\n\nThe data that is fetched in the Server component then passed as prop to the Client component, which needs to be serializable by React because it passes a Network boundary!\nObjects, arrays, strings, finite numbers,\ntrue, false, and null are serializable\ntypes of data.\n\nFunction, RegExp, and Error objects and the undefined value cannot be serialised or restored. (Source).\nThat means you cannot pass a function as\nprop to a Client Component returned by a\nServer component.\n\nIf you need to pass a component form the\nServer to the Client, you can pass a\nmapped string then render the component\nbased on that prop string on the Client\n\n#first\n4 April 2024\n16:57\nSchriften\nDB/MySql:\nCompound joined condition: joining multiple column together / joining two tables with more than one conditon\n17 April 2024\n20:51\nSchriften\nNextjs tips 16:\nGet path name in server nextjs book 16th\n\nUsing JavaScript you set a cookie:\n\u201cdocument.cookie = \u2018pathname\u2019;\n${pathname}; \u2018SameSite=Strict\u2019;\n\u2018Secure\u2019\u201d.\nThen read the cookie instead of the\nheader in the Server Compone\n21 April 2024\n11:24\nSchriften\n\u0641\u0631\u0627\u0646\u062a \u0686\u067e\u062a\u0631 \ud83e\udd55 21.04.2024 11:05:00\nPhoto\nNot included, change data exporting settings to download.\n1080\xd71080, 109.8 KB\n\ud83d\udef8 \u0634\u0645\u0627\u0631\u0647\u200c\u06cc \u0647\u0634\u062a\u0645 \u0627\u0632 \u0645\u0627\u0647\u0646\u0627\u0645\u0647\u200c\u06cc \u0647\u0648\u06cc\u062c \u062a\u0627\u06cc\u0645\u0632 \u0645\u0646\u062a\u0634\u0631 \u0634\u062f!\n\u062e\u0644\u0627\u0635\u0647\u200c\u06cc \u0627\u062e\u0628\u0627\u0631 \u062f\u0646\u06cc\u0627\u06cc \u0641\u0631\u0627\u0646\u062a\u200c\u0627\u0646\u062f \u062f\u0631 \u0645\u0627\u0647\u06cc \u06a9\u0647 \u06af\u0630\u0634\u062a \ud83e\ude82\n\n\u2b50 \u0648\u06cc\u0698\u0647 \u0634\u0645\u0627\u0631\u0647\u200c\u06cc \u0641\u0631\u0648\u0631\u062f\u06cc\u0646 \u0645\u0627\u0647 \ud83d\udd25\n\n\u0641\u0631\u0627\u0646\u062a \u0686\u067e\u062a\u0631\u061b \u0645\u062d\u06cc\u0637\u06cc \u0635\u0645\u06cc\u0645\u06cc \u0628\u0631\u0627\u06cc \u06af\u0641\u062a\u200c\u0648\u06af\u0648\u06cc \u062a\u062e\u0635\u0635\u06cc\n\ud83e\udd55@FrontChapter - #frontChapter\n22 April 2024\n10:50\nSchriften\n\u265a Erfan Nemati \ud83d\udc68\u200d\ud83d\udcbb \u265a 20.04.2024 21:26:22\nhttps://betterprogramming.pub/10-javascript-promise-challenges-before-you-start-an-interview-c9af8d4144ec\n10:50\nhttps://medium.com/frontend-canteen/10-code-challenges-to-master-promise-then-and-promise-catch-3da2bdea1d97\n26 April 2024\n15:38\nSchriften\nhttps://www.youtube.com/watch?v=mpcE5rxgLxM\n15:41\nIn reply to this message\nlifting up to the parent layout for preserving different states from different parent-child related routes\n15:59\nSchriften\nNextJs tips 29-30\nusing server actions and useFormState hooks which gives us the ability to write nodeJs in function and get rid of api call with fetch or axious.\n8 May 2024\n01:09\nSchriften\nthere is a different between promise constructor and a promise handler. costructor run sync and immediatelythe but the handler run always async.\ncostrcutor :\n\nconst promise1 = new Promise((resolve, reject) => {\nconsole.log(1)\nresolve(2)\n}\n)\n\nthis run both log and the 2. the num 2 is now resolved syncorlonsley.\n\npromise handler:\n\npromise1.then(res => {\nconsole.log(res)\n})\n\nconsole.log(\'end\');\n;\n\nthis .then is run always async. because of that, the response (2 which was already resoved at constructor) logged at the end and after the \'end\'.\n\ninside construcor we could have both async and sync actions but the handler runs always async. this prenvents blocking the event loop. the engine when reaches to the .then , it keeps running the codes below it and after finishing all tasks, it display the resolved action.\n\nthe whole code:\n\nconsole.log(\'start\');\n\nconst promise1 = new Promise((resolve, reject) => {\nconsole.log(1)\nresolve(2)\n})\n\npromise1.then(res => {\nconsole.log(res)\n})\n\nconsole.log(\'end\');;\n9 May 2024\n20:59\nSchriften\nconsole.log(\'start\');\n\nconst promise1 = new Promise((resolve, reject) => {\nconsole.log(1);\n// No resolve or reject called, so promise1 stays pending\n});\n\npromise1.then(res => {\nconsole.log(2); // This will not be called because promise1 is still pending\n});\n\nconsole.log(\'end\');\n\nresult is start,1,end\n\nnum 2 never logged. cause the promise must either resolve or reject and we must write this function explicitly til promise could change its state.\nwhen there is no resolve or reject state, promise will be stay at the peniding state.\nwhen the promise stays at penidng state, the .then func never called.\n.then calls only when the promise reloved or rejected, therefor the num 2 log never has been called.\n21:07\na Promise constructor is executed synchronously.\n22:31\nSchriften\nIn JavaScript EventLoop, there is also the concept of priority.\n\nTasks with higher priority are called microtasks. Includes: Promise, ObjectObserver, MutationObserver, process.nextTick, async/await .\nTasks with lower priority are called macrotasks. Includes: setTimeout , setInterval and XHR .\n10 May 2024\n15:45\nSchriften\nRendering never happens while the engine executes a task. It doesn\u2019t matter if the task takes a long time. Changes to the DOM are painted only after the task is complete.\n\nRender will be blocked until microtasks are finished so therefore also render will be blocked when you use lots of promises or it has heavy logic inside it\n15:56\nqueueMicrotask is a new browser API which can be used to convert your synchronous code into async.\n\ndiffernece with setTimeout/setInterval\nqueueMicrotask will execute microtask in a same queue after all sync microtasks are executed but setTimeout/interval execute tasks in a separate queue (macrotask queue) and because of that these tasks may not execute right after current task completes:\n\nhttps://freedium.cfd/https://medium.com/@kondareddy_yaramala/understanding-the-power-of-queuemicrotask-webapi-in-javascript-an-in-depth-analysis-eda07eb18009#:~:text=queueMicrotask%20is%20different%20from%20other,after%20the%20current%20task%20completes.\n20:48\nSchriften\nThings like HTTP Requests for AJAX, setTimeout are async (macro or micro) they dont live inside js engine they live in web api env.\nwhen we call them on js, their call back move them in the web api env and they wait until they\'re done, then based on priorities (macro - micro, etc) return to the queue and their callback will execute\n22:46\nSchriften\nconst [number, setNumber] = useState(0);\n\nreturn (\n<>\n\n<h1>{number}</h1>\n<button onClick={() => {\nsetNumber(number + 1);\nsetNumber(number + 1);\nsetNumber(number + 1);\n}}>+3</button>\n</>\n)\n}\n\nReact waits until all code in the event handlers has run before processing your state updates.\nthis feaure of react lets us update multiple states wihout trigerring too many re renderening. it batches all state updates in one re render. this feat called batching\n\n- Setting state does not change the variable in the existing render, but it requests a new render.\n- React processes state updates after event handlers have finished running. This is called batching.\n- To update some state multiple times in one event, you can use setNumber(n => n + 1) updater function.\n\ntheory:\nreact first run all the setStates in a handler (add them to the queue one by one) and then after compeleting the handler, it starts re rendering and changing states from reading and executing the queue.\n\nhttps://react.dev/learn/queueing-a-series-of-state-updates\n15 May 2024\n01:16\nSchriften\nregular func can be called before initiallazation cause they will be hoisted and go on top of their scope.\nbut arrow func since they have to be assigned to a variable, they can not hoist to the top of the scope as a function.\nhttps://www.freecodecamp.org/news/the-difference-between-arrow-functions-and-normal-functions/#:~:text=//%20ReferenceError%3A%20Cannot%20access%20%27printName%27%20before%20initialization\n17 May 2024\n16:38\nSchriften\nthis is not a property of the function or the object directly; instead, it is a special binding that depends on how the function is invoked.\nthis in js reffers to the context in which the func (that this is used there) called.\n21 May 2024\n17:48\nSchriften\nuseState is not async!:\nIn fact, setCount does its job synchronously. However, the updated value doesn\'t immediately reflect in the count variable because React batches state updates for performance reasons. This means the count variable isn\'t updated until the next render\n19:15\nSchriften\nBatching Updates: React batches multiple state updates that occur within the same event loop iteration to improve performance. This means that if you call setCount multiple times within the same function execution, React will only perform one re-render with the final state value.\n19:19\njs has two phases:\n1 - creating executuin context (compiling - hoisting - creating lexical scop env - memory allocation )\n2 - execution\n\nthe hoisting occurs in the first phase\n22 May 2024\n00:19\nSchriften\nhow preseving state in react:\nReact ensures that state updates are preserved between re-renders of the component. Even if the component function is called multiple times (e.g., due to re-renders triggered by parent component updates), the state remains consistent because it\'s associated with the component instance\n16:51\nSchriften\ndifference between OOP and FP\nFP emphasizes the use of pure functions, where the output is solely dependent on the input and has no side effects.\n\nin OOP we re using the logic by object inheritance concept. class can accept props of other class.\nin FP we re using code by creating higher order func: funcs that receive other funcs as arguments or retun them as result\n\nin FP we could use recursion over itration and make a loop by calling a func instide it instead of useing loop explicitly\n\nOOP uses mutable state within objects.\nFP uses immutable state and pure functions.\n\nOOP achieves reusability through inheritance and polymorphism.\nFP achieves reusability through function composition and higher-order functions.\n\npolymorphism: it allows an object to be an instance of its parent class. this concept lets us extent a loginc of a class to another classes.\nfunction composition: it allows us to combine functions for creating new function and more complicated logics. in composition, the output of a func could use as in input for antoher function.\n17:29\nSchriften\nwhen we use composition manually:\n\nconst add = x => x + 2;\nconst multiply = x => x \\* 3;\n\n// Function composition manually\nconst addThenMultiply = x => multiply(add(x));\n\nconsole.log(addThenMultiply(5));\n17:33\nwhen we use higher order functions for function compostion:\n\nconst add = x => x + 2;\nconst multiply = x => x \\* 3;\n\ncomposer = x => firstFunc(secFunct(x));\naddThenMultiply = composer(add,nultiply)\n\nconsole.log(addThenMultiply(5);\n17:47\ncodes in oop is mutable but in fp the best prctice is unmutablity. this is critical to a func to remain pure (result of a func should be separated from the input and input must be isolaited)\n18:07\nSchriften\nWhenever a component\'s state or props change, React triggers reconciliation.\nThe Reconciliation Process:\n\nNew Virtual DOM Creation: React creates a new virtual DOM reflecting the updated state or props.\nDiffing the Virtual DOMs: React compares the previous virtual DOM with the new one to identify the minimal set of changes required.\nUpdating the Real DOM: Based on the differences, React updates the real DOM efficiently. It might involve:\nModifying existing elements.\nAdding new elements.\nRemoving elements.\n23 May 2024\n02:02\nSchriften\nPhoto\nNot included, change data exporting settings to download.\n1280\xd7569, 55.5 KB\nhow react compiler cashes/memoizes the component and prevent unnessecry re rendering.\nby asigning the element to the array of cashable elements\n16:54\nSchriften\nlayout in nextJS:\nit allows us to build an wrapper around our page, which is stable when routing/navigating. layout is a good idea for developing footer /header of an app and other fixed component.\nwe could preserve the state that we create in layout in all sub pages/layout.\n\ntemplate in nextJs:\nwith template is also a wrapper around the page, but it doesnt preserve the state of its page during navigiation/routing, instead it will be re mounted after navigation.\nwhen we want to call an action each time the user enter a page, template is a good idea and we shouldnt use layout for this.\n24 May 2024\n20:18\nSchriften\nabout && operator:\nit returns the first falsy value or the last turthy one:\nfalse && false && asb => false\nnull && false && undefiend => null\ntrue && true && asb => asb\n20:34\nSchriften\nevents in js:\neventPropagation: it has 2 kinds => bubbling - capturing:\nbubbling: the event starts to grow from inner element to outer (thats the default behavior of an event in js. to prevent that: e.stopPropation)\ncapturing: when the event starts from the outher element and keeps moving to the inners. (thats not the default behavior and to make it we can pass the third arugment of enventListener a true value):\n\n.addEventListener(\'click\', function() {\nalert("I\'m a div");\n}, true);\n\n- when the preventDefault is called, the defualtPrevented prop in the element obj is true. e.defaultPrevented = true\n  20:44\n  e.preventDefault:\n  prevent the calling event to have its default actions unless we command them explicitly. when we use it insdie a form submission event, it wont let us submit.\n  31 May 2024\n  18:02\n  Schriften\n  about event loop - web apis and\n  js is single threaded (it only has one call stack on no more) it can not do taks in parallel. for this reason we use web apis to hadle long running tasks.\n  but how:\n  some of these web apis allow us to offload long running tasks to the browser and when we call those apis we just initiate the offloading.\n\nwhats the task of event loop?\nit checks if the call stack is empty. if nothing is running it gets the first available tasks from the tasks queue and gives it to the call stack and so on.\n\nso if there are tasks running in the callstack , async tasks should wait in the queue even they\'re done. therefor some tasks like setTitmeOut doesnt exacly run on the exact given time.\n18:09\nweb apis are devided to two part:\ncallback based apis (macro task)\npromise based apis (micro task)\n\nevent loop in js has antoher responsibility and that is to find and differ micro tasks from macro tasks.\nit first gives all the promise based apis (like async fun, fetch, promise mutaionObserver, queueMicroTask...) to the callStack and when the micro tasks qeue is empty, pass only one macro task to the callstack and so on.\n18:14\nbecarefull about infinite microtask loop!\nWhen we do some microtask and inside that taks another micro task, this microtasks could block the enire queue of our macro tasks queue.\n3 June 2024\n20:24\nSchriften\nimporve performance:\nprevent links to preload\nimport components which we dont use them on page load dynamically\nmigrate from sass modules to tailwindCss\nprevent unnecessary re rendering by refactoring scrollDirection and scrollPosition feats.\nmigrate to next14 for imporving server side rendering of components - cashing systen - take advantage of server component in next14\nimprovement components. server side rendering by separating static parts of the component from dynamic parts.\npass the clinets components as a children to server components for impoving the ssr and use the ssred component as a layout component.\n20:38\nPhoto\nNot included, change data exporting settings to download.\n1280\xd7710, 70.6 KB\nwhat we do in promise resolve part, we can get it in the .then part of the promise asynchronously.\n4 June 2024\n14:35\nSchriften\nSSG: statice site generation:\nits a sort of rendering for webPAges. in that the webPage and contents are pre-rendered at build time (no request to server for getting data ) and each time we meet the page, our request gets data from cdn and not server. in this method any change require rebuilding the entire site.\n14:37\nISR: Incremental static regeneration\nits a combination between ssr and ssg . i this method the webpage is pre-rendered at build time in cdn (like ssg) but there are several methods for revalidating this data on specific time or on demand.\n15:56\nSchriften\nSWR cashing is different from SSG. it cashes on the client side and in localstorage. when we request some data again, it checkes if the cashed data not stale and if its true, it rerurns the cashed data on client side.\n7 June 2024\n13:58\nSchriften\nabout itrating in js\nin js all objects, strings and Sets have a default symbol.iterator which allows them to be iterable.\nSymbol.iterator is a built-in symbol that specifies the default iterator for an object\n\nconst arr = [1, 2, 3];\n\n// The array has a Symbol.iterator method\nconst iterator = arr[Symbol.iterator]();\n\nconsole.log(iterator.next()); // { value: 1, done: false }\n14:17\nSchriften\nIterable: An object that has a Symbol.iterator method.\nIterator: An object with a next() method that returns { value, done }.\n12 June 2024\n00:29\nSchriften\nabout WAF - Web aplication firewall:\n\nIt typically protects web applications from attacks such as cross-site forgery, cross-site-scripting (XSS), file inclusion, and SQL injection, among others.\nWhile a proxy server protects a client machine\u2019s identity by using an intermediary, a WAF is a type of reverse-proxy, protecting the server from exposure by having clients pass through the WAF before reaching the server.\n13 June 2024\n16:13\nSchriften\nPrototype in Js\nin js all varialbles could access some methods and props by inheritence. they all have an access to a prop named prototype.\nthats why we could use str.splice or array.toString in variables.\nalso we could add custom methods or props in a func constructor by using prototype:\n\nfunction Person(first, last, age, eyecolor) {\nthis.firstName = first;\nthis.lastName = last;\nthis.age = age;\nthis.eyeColor = eyecolor;\n}\n\nPerson.prototype.name = function() {\nreturn this.firstName + " " + this.lastName;\n};\n17:29\nSchriften\nuseEffect - useLayoutEffect\nboth of the are for performing sideEffects. the key difference is the point of performing these sideEffects in component lifeCycle.\n\nuseEffect is async and its wait for dom for all mutaion to happend and then wait for all changes to paint in the screen, then it perform the sideEffect and update the ui so user can see the ui updates.\n\nuseLayoutEffect is sync. after all dom mutaion is complete, it will block the screen from updating until all sideEffect performed then ui updates and screen will repaint.\nuseLAyout useCase is when we want to add some loginc to measure layout or add some thing which affects the ui-layout and its better to add it before ui update.\n\nso useEffect is async and it will not block the ui from update.\nuse layout is sync and it will block ui from update until all effect is perormed in Dom\n\nThe effects exsiting in useEffect perform after ui update and in the next rendering cycle\n21:10\nSchriften\nAbout Rendering proccess:\n\nFirst js will execute then all styles differences will be calculated\nThen reflow (layout) happens:\nIn this phase the position and the size of all Elements will be calculated with the previous Version.\n\nThen paint happens:\nIn this phase all the styleing updates will be performed in the elements and pixels will be filled with them.\n\nThen composite happens:\nIn this phase all of the updates element will be combined together\n14 June 2024\n13:30\nSchriften\nuseMemo and useCallBack differnece\nwe use useMemo to memoized a return value and result of a functionaity. useMemo ensures that a re-calclation of an expencive logic only happens when the dependecies changed.\nalso we use it when the drived state (the state we\'re passing it to the child component and want to make some calculation on that in a child) only re run when this state changed.\nthen we use useMemo to prevent recalculation of an expencive logic on every re-render.\n\nconst expensiveCalculation = (num) => {\nconsole.log(\'Calculating...\');\nreturn num \\* 2;\n};\n\nconst MyComponent = ({ number }) => {\nconst memoizedValue = useMemo(() => expensiveCalculation(number), [number]);\n\nreturn <div>{memoizedValue}</div>;\n};\n\nuseCallBack:\nwe use useCallback to memoize a functionality it self and for example pass it to a child component.\nuseCallback ensures that a function only be called when one of its dependecies changed:\n\n//in a parent component we wrote a memoized onClik func:\nconst memoizedCallback = useCallback(() => {\ndoSomething(a, b);\n}, [a, b]);\n\n//in a child component we passed this memoized onClick func. it calls only whe the value of this eventHandler changed.\nconst MyComponent = ({ value }) => {\nconst handleClick = useCallback(() => {\nconsole.log(value);\n}, [value]);\n\nreturn <button onClick={handleClick}>Click me</button>;\n};\n\n#here\n14:00\nSchriften\nBoth useMemo and useCallback can be used to optimize performance in a React (or Next.js) application by memoizing values and functions respectively, and their use cases can sometimes overlap\n14:04\noverusing memoization: Each memoized value or function is stored in memory, which could lead to increased memory usage if overused.\n18:14\nSchriften\nwhere axactly useMemo and useCallback cashe the value or func:\nwhen in react each eleement or component has a fiber node. fiber node represents each component in react strucutre. when we\'re passing a value/prop/func to a component , react attaches these props to its related fiber node and preserve it for differeing them from old and new version.\n18:18\nwhen a react comp is mounted, react create a fiber node for it. then when the hook is called, react attaches the value or funcs to its fiber.\nwhen the deps are not changed, react use the same value or func in fiber node in re rendering process. when the deps have changed, react re cacualte the funcs or call the func again and update the fiber node\n.\n18:33\nSchriften\nOn the initial render, React creates the function and stores it in the fiber node.\nOn subsequent renders, React checks [value]\n18:41\noverusing memoization leads to:\nIncreased Garbage Collection Activity.\nMemory Leaks\n18:49\nfiber node are created during the rendering process of components\n19:06\nSchriften\nrendering and mounting process in react:\nrender phase: call a render method of each component to create a new v-dom\nreconcilation: differing this new v-dom to old v-dom\ncommit phase: applying change from to r-dom and mounting component. useEffect runs in this phase. i.e when the component is mounted\n19:13\nuseEffect runs after comonent is mountned (it runs after commit phase) and when its deps is changed, it triggers a re render.\nuseMemo or callback runs in render phase and passed to their related to fiber to be stored and differ in next rendering procces.\n\nso useEffect runs after commit phase , useMemo or callback run in render phase.\n19 June 2024\n19:58\nSchriften\nuseRef:\nthere are two kind of refs: string and callback.\nstring refs are direcly set in the dom and callback is set in the func and this func calls on comonent instance or the dom element when they\'re mounted or updated.\nwe use refs when we want to access some elment/components props or methods which are not accesible in the components props.\ni.e we use refs when we want to access the underlying methods of dom elements or dom it self or instances of them.\n\nfunction MyComponent() {\nconst myRef = useRef(null);\n\nconst handleClick = () => {\nmyRef.current.focus();\n};\n\nreturn (\n<>\n<input type="text" ref={myRef} />\n<button onClick={handleClick}>Focus input</button>\n</>\n);\n}\n20:23\nSchriften\nhow useRef works:\nconst ref = useRef(null)\n\nwhen we call the useRef and asgin it to a var, it return a mutable obj with a prop named current which we can set any value to it.\nin the above case, we use the myRef as a refference to a dom element, so the current obj can access the dom element methods.\nin this case, current reffers to input element and its method i.e focus.\n20:38\nSchriften\ncallBackRefs:\nwe can wirte a func and pass it as a ref to an element instead of using useRef.\nwe write a setter func which get an element as an arg and asgin it to variable.\nwhen we pass this setter fun to an element, this element asgin to that variable and then we could use that var inside another func to access its underlying dom methods:\n\nlet ref = null;\n\nfunction setRef(element) {\nref = element;\n}\nfunction handle() {\nif (ref) {\nref.focus();\n}\n}\n\n  <input className=\'bg-v2-text-low_em w-1/2 mr-10\' ref={setRef} />\n      <ButtonV2 onClick={handle}>ddd</ButtonV2>\n20:46\nwhen we could use callbackRefs:\nwhen we want to pass refs to some elements which rendered or destroyed conditionally.\nif we make a custom ref in this way we have more control on passing ref to the elements.\n\ntriggering actions or sideEffect on component life cycle:\nwe can make some action this way when component mounted or unmounted. we could pass the seterFunc as a ref only when the component is mounted.\n\nfunction MyComponent() {\nconst [showInput, setShowInput] = useState(false);\n\nconst handleToggle = () => setShowInput(!showInput);\n\nconst setRef = (element) => {\nif (element) {\n// Element is being mounted\nelement.focus();\n} else {\n// Element is being unmounted\nconsole.log(\'Element is unmounting\');\n}\n};\n\nreturn (\n<>\n<button onClick={handleToggle}>Toggle Input</button>\n{showInput && <input type="text" ref={setRef} />}\n</>\n);\n}\n\nprevent stale clousure\nwhen some data that must be updated during re-render , remains the same. this could happen when we use useRef. since useRef creates an obj that persist across re-renders. but with custom ref / callback ref we could prevent this , cause the func always calls after re-render and gives us the last instance of the refferencing element.\n21:19\nSchriften\nwhen useRef called?\nuseRef call on rendering phase and with every re-render.\non the initial render , it calls in this phase and sets the value to the initial value (null in our case) . then react recocile the dom and v dom and then the commit phase starts. in this phase react commit the changes from v-dom to actual dom. in this phase react asign the ref courrent prop to the refferenced element in dom.\n\nthen useRef calls in rendering phase (set to null), it updates the current on commit phase(with element).(this is related to initial render) .\non every re-render the current asigned value persist. so when the useRef calls on rendering phase in every re-render it returns the same current prop.\n21:33\ncommit phase is the last phase of react reconcilation proccess. its unstopable in this phase react runs these the life cycle methods:\ncomponentDidMount, componentDidUpdate, and componentWillUnmount.\nassignment of ref cuurent prop occurs right before commonentDidMount /update/ called. didupdate in init render and didUpdate in re-rendering\n21:35\nuseEffect called after componentDidMount and useRef called in rendering phase and it reasigned before componentDidMount\n24 June 2024\n15:43\nSchriften\nprivatives are passed to variables by their values. but none-primitives (obj, arr, func) are passed to variables by their reference. that the reason why we cant reasign a const variable from an obj to aother but we could mutate its value props.\n\nReaign a variable means changing its reference. let,var allow us to do that but const doesnt allow us.\n27 June 2024\n19:19\nSchriften\nsymbol:\nthey are identifier and unique and unmutable primative in js.\nwe could use them to create different and unique key for object.\n\nalso there are some well-known predefined symbols in js. with them we could change some default behavior of js and create a custom behavior.\nie with symbol.iterator we could make a obj iterable:\n\nconst myIterable = { \\*[Symbol.iterator]() {\nyield 1;\nyield 2;\nyield 3;\n}\n};\n\nfor (const value of myIterable) {\nconsole.log(value); // 1, 2, 3\n}\n\nSymbol.toPrimitive\n\nconst obj = {\nname: "Alice",\nage: 25,\n[Symbol.toPrimitive](hint) {\nif (hint === "string") {\nreturn `Name: ${this.name}, Age: ${this.age}`;\n}\nreturn null;\n}\n};\n\nwe use it to turn an obj to a privmative value\nSchriften pinned this message\n28 June 2024\n21:30\nSchriften\nreact portal\nit allows us to render a child outside of the parent/child hierarchy of the dom. this child exists outside of the hierarchy and can be used every where in the dom.\nuseage:\nfirst create a dom node:\n\n\x3c!-- In your HTML file --\x3e\n\n```html\n<body>\n  <div id="root"></div>\n  <div id="portal-root"></div>\n</body>\n\ncreate the portal component:\n\n// PortalDemo.js\nimport React from \'react\';\nimport ReactDOM from \'react-dom\';\n\nconst PortalDemo = ({ children }) => {\nconst portalRoot = document.getElementById(\'portal-root\');\nreturn ReactDOM.createPortal(children, portalRoot);\n};\n\nexport default PortalDemo;\n1 July 2024\n00:42\nSchriften\nabout setImidiate:\nin introduce in nodeJs to handle async operation. its not available on browser and istead of it we could use setTimeOut which is a little differnet and percise than setTimeout.\n\nsetImidiate allows us to execute a task riight after current eventLoop itration is over.\nie is the fist task that execute right after the current evLoog itration is over.\nnote that we are taking about nodeJs event loop.\n\ninside those apps which has server-side rendering like nextJs we could use setImidiate because NextJs run in server and client both , so it has access to both node and js apis.\nbut inside a standart react app we do not have such an access unless we use some polyfill wich gives us a compatible (an alternative) code, so we could use setImidatie in js env too.\n00:44\ngenerally polyfills are a piece of code which allow us to use new feats or apis that are not supported in a browser or a native env.\n01:39\nSchriften\nabout node and js envs relations:\nNode.js provides a runtime environment for executing JavaScript code outside of the browser.\n\nclient side js runs by the browser and server-side runs by node.\n\njavascript runs in the context of the Window and the Dom.\nevery vars defined in the global scope of the js are props of the window\njs in browser interacts with DOM . DOM is a representation to the Html elements and it has some props to interact and manipulate the element, like doc.getElementById , appendChild, window.document and so on.\nWidow obj represents the browser window and it gives us some method to intract with it, like window.console setTimeOut , scroll., fetch..\n01:48\nthe different between dom and html element:\nhtml is stored at the web server. when we visit a web page we req the server and get the htmls. browser gets the htmls and compile it to what we see. but html is a static structure and cant be changed or manipulate by it self. after html is served and displayed in the browser , browser parses it to an obj named DOM and all element becomes a node in DOM tree. DOM is stored in the browser memory and can be changed and modified by javascript.\n02:01\nthen we can say, client-side js runs on browser through window obj and the serverside js runs in nodeJS env thorigh globalContext.\n5 July 2024\n00:50\nSchriften\nabout javascript phase:\nwhen html req script and fetch it, the first phase begins:\nit is called compiling:\nin compling phase js engine create lexical global scope. this env has access to the browser obj window.\n\n#the key envents in this phase:\naccessing window obj.\n\n- hoisting var and global variable to the top of the scope\n- initialzing them to undefined\n- hoisting func declartion and invoking them to create the function scope\n- hoisting let and const and other blocked scope\n  01:09\n  Schriften\n  #the key envent in the scond phase : execution phase:\n  execuiton happens line by line:\n- var and global variable assigned to their related values\n- functioons executed\n- let will be initialized to the value of that line which declares it\n- const must be initialzed to a value on the exact line of creation and it cant be changed.\n  01:30\n  Schriften\n  when we declare a varible without let const and var, it will be hoisted to the global obj or window obj.\n  but var is different. when we declare it inside a {} it will be hoisted to global lexical env as a prop of window or global. and when we declare it inside a func scope it will be hoisted on top of that func scope. (not a global variable any more)\n  01:46\n  Schriften\n  compiling phase (hoisting) in js not happens line by line. it happens based on scope priority. it first scans in global scope looking for funcs, var and let or const and hoists them on top of global scope.\n\nthen it will scan inside func scopes and do exactly that hoisting inside them.\n\nthen it will scan other blocked scope like if , loop or simple {}.\n02:04\nSchriften\nhoisting in js happens based on scope and not line by line:\nfirst everyyhing in global scope:\n\n- funcs\n- var\n- let const\n\nsec everything in funcs scope:\n\n- funcs and nested funcs and nested funcs in them\n- var\n- let const\n\n- other blocked scopes like {}, if, loop\n  02:18\n  the diffenet betweeen this fucking 2 lines :)))\n\nconsole.log(x);\nvar x = 2;\n\n// this will log undefined , cause the declaration : var x, will be hoisted and initialized to undefined:\nvar x = undefinded\nconsole.log(x)\nx = 2\n\nconsole.log(x);\nx = 2;\n\n// this will be a refference err x in not defined. cause x = 2 is an asginment and not a declation and we want to access a varibale value before its assignment.\n\nboth this assignment happened in globalscope but only first one will be initiallized in the hoisting time . the sec initialliezed when assignment happens.\n02:26\nthe var x = 2 or x = 2\nin clinet js , is a window property.\n\nbut the var x = 2 in node is not a global propery: global.x = undefined\nits a module prop.\nx = 2 but is a global prop in node\n15:38\nSchriften\nabout lexical env parts:\nfirst: env record:\nit stored funcs , parameters, varibale declaraion and asignment and generally handle the bindg between variables and their values inside thee scope.\n\nsec: env outer referrence:\nthis is a referrence to the outer lexical env (parent) of the current one (child) this part makes a chain of envs that can be goes from down to up when a variable not fount in a scope.\n15:55\nSchriften\nlexical env outer referrence is created in compling time but its useage is at execution time.\nit connects child scope to the parent and when a varibale are not hoisted and stored in a env record it goes up and search the parent scope env record.\n16:50\nSchriften\nthe compling and creating lexical envs parts and hoisting phase of js happen in the execution context creation.\n16:51\njs has 2 phase then:\nexection context creation (compling)\nexecuion phase\n16:52\nscope chaining. its the function of env outer reference\n\nabout garbage collection:\n\nClosures Can Prevent Garbage Collection:\n\nIf an inner function (closure) maintains a reference to a variable from an outer scope, that variable won\'t be garbage collected, even if the outer function has finished executing.\njs\nCopy\nEdit\nfunction outer() {\nlet data = "I am still here"; // Normally, this would be garbage collected\n\n    return function inner() {\n        console.log(data); // Closure keeps "data" alive\n    };\n\n}\n\nlet keepAlive = outer(); // "data" is still in memory because of inner()\nkeepAlive(); // Logs: "I am still here"\n8 July 2024\n19:59\nSchriften\nwebP vs svg:\nsvg format is resolutuon independent and its suitable for logo icons . but webp is good for complex graphics that benefit from rasterization\n\nwebp reduce bandwidth and faster load time and has SEO benefits because it affects the load time of sources.\n\nin nextJs the image component autimatically serves the image with the format thats compatible with the user browser. if it supports webP the webP.\nsvgs are a differenrt format and they\'re not trnasormed to webP when served. and there is no need for that.\n19:59\nsvgs are vecor format and webP, png, Jpeg are rastor.\n\nrastor made of pixles and each pixle has a unique color and fixed resulition thats why rastor format images are suitable for complex graghics like deaitled image and photos.\n\nvector made of tiny parts difined by mathematical equation this parts can be various shapes, lines text ... . thats why the svgs are suitable for simple graghi. and icon and resulution free\n23:28\nSchriften\n#performance:\n\ndecrease FCP load time by preloading FCP contents like banners\ndecrease initial loading time of sources by turing off the prefetch prop in some unnecessary Link component\nlayzy loading components to imporve FCP and LCP speed\nSSRed component and server cashing for static component by seprating logical component from static ones.\nuse custom Image component instead of next Image which helped to speed up the build time: next Image has very complex configration of resizing , bluring , format swithcing image and we dont need all of them.\nprevent unnecessary rendering because of scroll pos.\nchange from sass modules to tailwind to prevent scss barrel files to laod on every page.\n\nchange method of exporting compoent from default to named for helping tree shaking barreld files:\ndefault exported component could have any name and this way its defficult for tree shaker to detect which part of the code are in used.\n\nhelp tree shaking process by making a pattern for importing component or libraries and set a \'modularizeImports\' field to transform\n\nimport { debounce } from \'lodash\'\n\nto\n\nimport debounce from \'lodash/debounce\'\n\n#perf\n23:42\nturbopach handled the dev env building. nextJs copiler is the build tool for production\n9 July 2024\n00:01\nSchriften\nnextJs use swc for compiling and minification on production not babel\n00:04\nnextJs uses Turbopack for dev build . (next dev) it has a speedy build process and hot module replacement . in production, it uses next compiler (SWC speedy web compiler)\n00:04\nHot Module Replacement (HMR): It enables HMR, allowing you to see changes reflected in your browser almost instantly without a full page reload\n10 July 2024\n11:52\nSchriften\ncall, apply , bind methods:\n\nthese methods helping us to manipulate or cusomize a func behavior considering their this binding and the argument we\'re passing them:\n\n// when we call a func with apply, it recive an arg which specify the this behavior and an array of args we\'re passing to the func\nfunction greet(name) {\nconsole.log(`Hello, ${name}!`);\n}\n\ngreet.apply(null, [\'Alice\']);\n\ncall method is exacty like apply but it acecpet infinte value as args:\nfunction greet(name) {\nconsole.log(`Hello, ${name}!`);\n}\n\ngreet.call(null, \'Bob\');\n\nbind method create anouter func with special binding and we could use that func\nfunction greet(name) {\nconsole.log(`Hello, ${name}!`);\n}\n\nlet greetBob = greet.bind(null, \'Bob\');\ngreetBob();\n12 July 2024\n20:21\nSchriften\nline by line executiion in js:\nthe proccess of executuion in js is line by line . but consider this: when in line by line executing js reaches to a func, it calls it, the func call create aother execution context and push it to a callstack. by calling a func, the process of line by line executing is paused and the new context will executed line by line untl it reaches to another func and so on.\n20:22\nThis nested structure is handled by the call stack, ensuring that the most recent function call is completed first (Last In, First Out - LIFO).\n20:33\nThere are two primary types of execution contexts: the global context and function contexts.\n15 July 2024\n15:57\nSchriften\nGit Essentials.pdf\nNot included, change data exporting settings to download.\n5.8 MB\n19 July 2024\n02:27\nSchriften\nAST or Abstract Syntax Tree in js\nit created in compile (parsing time). it is a haiarchial structure represnted the source code. it turns souce code to some tokens with all syntax and scope relation of the source code.\nuseage:\ntools like esLint detecting errors warning and best practice with help of AST.\nlibs like babel use and manimulate ASTs for parsing moders es6+ js to the older versions and make js backward compatible.\nthe js soruce code must converted at the end to bytecode for execution and this process happens on AST.\n\none the most important useage of AST is catching syntax errors. when code is parsing the, this steps checks if the syntax rules of js is considered in code or not. this process happens before execution and can prevent run time err.\n02:29\nconst sum = (a, b) => a + b;\n\nProgram\n\u2514\u2500\u2500 VariableDeclaration\n\u251c\u2500\u2500 VariableDeclarator\n\u251c\u2500\u2500 Identifier (sum)\n\u2514\u2500\u2500 ArrowFunctionExpression\n\u251c\u2500\u2500 Parameters (a, b)\n\u2514\u2500\u2500 BinaryExpression (+)\n\u251c\u2500\u2500 Identifier (a)\n\u2514\u2500\u2500 Identifier (b)\n02:44\nSchriften\njs parses in browser with JS engine. each browser has its own js engine:\n\n- chrome , edge , opera have V8\n- fireFox has spiderMonkey\n- safari has JavaScriptCore\n- IE and legacy edge have Chakra\n  02:50\n  then browser handle parsing internally and will catch syntax err before execution.\n  but in dev env developers need some comilers to this job before rendering or sending anything to the browser and during development.\n  libs like babel, EsPrisma, typescript compiler (tsc)\n  20:38\n  Schriften\n  about eval method in js\n  when we want to execute js directly and without compiling and make ast of it, we could use eval method and pass the func as string to it. it executes the source code it self.\n  useage of eval:\n- executing some codes which are generated at runtime .\n- executing scripts which are translated in js only at runtime\n\nDrawbacks of eval\n\n- code injection and not secure\n- performance issues because of executing the source code and not the parsed code.\n\neval is a global func and a prop of window obj.\n21:01\nSchriften\nabout garbage collection algorithm\nthe most common alg in js is mark and sweep.\njs marks all global obj and its referrenced objec or func - vars and local vars which are inherently reffrenced by global obj as reachable.\nthis process coontinues untill all reachable objs are marked. then js scans in memory and find unmarked objs (objc with no refference and useage and then Reclaim the memory occupied by these unmarked objects.\n31 July 2024\n01:05\nSchriften\nwhen useState is called:\n\n- in initial render, it calls and initalaized its state with the given inital value\n- in next renders it reads state from internal state.\n\n- when setter func of useState is called the state is updated but not jet diplayed only the old internal states is replaced by the new one . in the next steps the re-render is happened, in this phase useState is called again and read the new state.\n- setter is called\n- setter update the state with new state (batcing is in this phase\n- first update and baching .then() re-render happens and state will be read from useState internall state\n  8 August 2024\n  17:31\n  Schriften\n  about loading css and html:\n  html and css are loaded in parrarel. but first html is requested and in process of parsing html when browser reaches the style tag or link tag with css a reffrence it starts to req css.\n\n- html parse to DOM and css parse to CSSOM\n\n- css is render blocking . browser wont render and paint html before css is fully loaded because preventing FOUC\n\n- DOM and CSSOM are combined it to render tree\n\n- then painting starts according to this render tree.\n  16 August 2024\n  00:58\n  Schriften\n  about throthle and debouche:\n  in thorothle we limit a func execution in a period of time. means the func must be executed only once in a specific time:\n\nfunction throttle(func, delay) {\nlet lastCall = 0;\nreturn function(...args) {\nconst now = (new Date).getTime();\nif (now - lastCall < delay) {\nreturn;\n}\nlastCall = now;\nreturn func(...args);\n};\n}\n\n// Usage Example\nwindow.addEventListener(\'resize\', throttle(function() {\nconsole.log(\'Resized!\');\n}, 1000));\n\ndebouce ensures the func executed only after the event triggered and the specifice time is passed . means it ensures that a func be executed only when a specific time is passed from triggering an event.\n\nfunction debounce(func, delay) {\nlet timeoutId;\nreturn function(...args) {\nclearTimeout(timeoutId);\ntimeoutId = setTimeout(() => {\nfunc(...args);\n}, delay);\n};\n}\n\n// Usage Example\nconst searchInput = document.getElementById(\'searchInput\');\nsearchInput.addEventListener(\'input\', debounce(function(event) {\nconsole.log(\'Search Query:\', event.target.value);\n}, 300));\n13:37\nSchriften\nappRouter and page router:\npages router was the inital routing sysyem of next, you define your pages inside pages dir it was much simpler.\nappRouter is the new v of routing. it lets us to create nested Route with different layout/template which can rendered totally on server(layout) and not re render on route changing. it unlucks server component also.\n14:23\nSchriften\nanother feat of next app router is streaming. it alows the component not only rendered on server , also it send these parts chunk by chunk to browser and will not wait for whole page to be fully rendered anymore.\n24 August 2024\n00:53\nSchriften\nabout shadow dom\nwith shadow dom we could create another dom inside the dom to encapsulate the shadow from real. we do that when we want to make sure that a custom component inisde the shadow dom wont be affected by js logics or css styling in outer dom dom and also the shadow dom wont affect them.\n\n<body>\n    <greeting-message></greeting-message>\n\n    <script>\n        // Define a new class for the custom element\n        class GreetingMessage extends HTMLElement {\n            constructor() {\n                super(); // Always call super() first in the constructor.\n                const shadow = this.attachShadow({ mode: \'open\' });\n                const wrapper = document.createElement(\'div\');\n                wrapper.textContent = \'Hello, world!\';\n\n                // Add some styles to the shadow DOM\n                const style = document.createElement(\'style\');\n                style.textContent = `\n                    div {\n                        color: white;\n                        background-color: black;\n                        padding: 10px;\n                        border-radius: 5px;\n                    }\n                `;\n                shadow.appendChild(style);\n                shadow.appendChild(wrapper);\n            }\n        }\n        customElements.define(\'greeting-message\', GreetingMessage);\n    <\/script>\n\n25 August 2024\n00:02\nSchriften\nshallow copy and deep copy\nwhen we shallow copy an obj, this process copy all the top level props (means non-nested props like obj or arr) and when in that cpied obj exists some nested props , they will be shared between to variabale.\n\n- shallow copy , copy the top level prop with (primary values) and only copy the refferences of nested props.\n- deep copy, copy all of the obj / arr props.\n\nshallow copy:\n\nconst original = { prop: 123, nested: { innerProp: 456 } };\nconst shallowCopy = Object.assign({}, original);\n\nshallowCopy.prop = 789;\nshallowCopy.nested.innerProp = 999;\n\nconsole.log(original.prop); // Outputs: 123 (different value, since primitive values are copied)\nconsole.log(original.nested.innerProp); // Outputs: 999 (same object, so nested object is shared)\n\nconst original = { prop: 123, nested: { innerProp: 456 } };\nconst shallowCopy = { ...original };\n\nshallowCopy.prop = 789;\nshallowCopy.nested.innerProp = 999;\n\nconsole.log(original.prop); // Outputs: 123 (primitive value is copied)\nconsole.log(original.nested.innerProp); // Outputs: 999 (nested object is shared)\n28 August 2024\n09:57\nSchriften\nabout new Map:\nits for creating obj. it allows us to create key - value pairs llike regular obj with this differences:\n\n- keys can be anything even func\n- it preseve the exact order of props when mapping through the props\n- its faster when it comes to removal and adding prop:\n\nconst map = new Map();\nmap.set(\'name\', \'John\'); // String as a key\nmap.set(1, \'one\'); // Number as a key\nmap.set(true, \'yes\'); // Boolean as a key\n\nconsole.log(map.get(\'name\'));\n\n//map through the Map obj:\n// Using for...of\nfor (const [key, value] of map) {\nconsole.log(key, value);\n}\n\n// Using forEach\nmap.forEach((value, key) => {\nconsole.log(key, value);\n});\n11:11\nSchriften\nabout new WeakMap:\nits like Map but only accept obj as key and it holds a weak refference to that obj i.e when there is no outer reffernece to that obj, the related prop of the weak map obj, will be garbage collected (removed) automatically.\n\nwe could use weakmap to hold private data or to prevent memory leaks by using eventHandlers.\nweak map is not iterable.\nexample of uing Weakmap in handling event:\n\n// Create a WeakMap to store click counts associated with each element\nconst clickCounts = new WeakMap();\n\n// Function to handle click events\nfunction handleClick(event) {\nconst element = event.currentTarget;\n\n// Get the current count or initialize it to 0 if it\'s the first click\nlet count = clickCounts.get(element) || 0;\ncount += 1;\n\n// Update the click count in the WeakMap\nclickCounts.set(element, count);\n\nconsole.log(`Element clicked ${count} times`);\n}\n\n// Create some buttons to demonstrate\nconst button1 = document.createElement(\'button\');\nbutton1.textContent = \'Button 1\';\nbutton1.style.margin = \'5px\';\n\nconst button2 = document.createElement(\'button\');\nbutton2.textContent = \'Button 2\';\nbutton2.style.margin = \'5px\';\n\n// Attach event listeners to the buttons\nbutton1.addEventListener(\'click\', handleClick);\nbutton2.addEventListener(\'click\', handleClick);\n\n// Add the buttons to the document body\ndocument.body.appendChild(button1);\ndocument.body.appendChild(button2);\n\n// Example: Removing button1 from the DOM after some time\nsetTimeout(() => {\ndocument.body.removeChild(button1);\nconsole.log(\'Button 1 removed from the DOM\');\n}, 5000); // Remove after 5 seconds\n\nwhen the btn is removed from dom, the handler inside the handleClick func can not call anymore and the clickCount variable has no other refference.\n31 August 2024\n20:05\nSchriften\nReact_18_Design_Patterns_and_Best_Practices_Design,\\_build,\\_and_deploy.pdf\nNot included, change data exporting settings to download.\n12.7 MB\n#book\n2 September 2024\n18:21\nSchriften\nuseOnNavigationBAckV2 - solved the modalHash replaceing with query issue:\n\nimport { useGetAsPath } from \'@/hooks/useGetAsPath\';\nimport { SimpleFunction } from \'@/types\';\nimport { useParams, useRouter } from \'next/navigation\';\nimport { useEffect } from \'react\';\n\nconst currentModeRef: {\nmodalId: string | null;\nstate: \'opening\' | \'closing\' | \'idle\';\nonCloseCallback: SimpleFunction | null;\n} = { state: \'idle\', modalId: null, onCloseCallback: null };\n\ninterface Props {\nonClose?: SimpleFunction;\n}\n\nconst updateModalState = () => {\nif (currentModeRef.state === \'opening\' && currentModeRef.modalId === window.location.hash) {\ncurrentModeRef.state = \'idle\';\ncurrentModeRef.modalId = null;\nreturn;\n}\nif (currentModeRef.state === \'closing\' && currentModeRef.modalId !== window.location.hash) {\ncurrentModeRef.state = \'idle\';\ncurrentModeRef.onCloseCallback?.();\ncurrentModeRef.onCloseCallback = null;\ncurrentModeRef.modalId = null;\nreturn;\n}\nif (currentModeRef.state === \'idle\' && !window.location.hash) {\ncurrentModeRef.onCloseCallback?.();\ncurrentModeRef.onCloseCallback = null;\ncurrentModeRef.modalId = null;\n}\n};\n\nexport function useOnNativeBackV2({ onClose }: Props = {}) {\nconst router = useRouter();\nconst path = useGetAsPath();\n\nconst addHashToUrl = (modalHashId: `#${string}`) => {\nconst currentUrl = new URL(window.location.href);\ncurrentUrl.hash = modalHashId;\nreturn currentUrl.toString();\n};\n\nreturn {\nopenModal: (modalHashId: `#${string}`) => {\ncurrentModeRef.onCloseCallback = onClose || null;\nif (currentModeRef.state === \'idle\' && currentModeRef.modalId !== modalHashId) {\ncurrentModeRef.state = \'opening\';\ncurrentModeRef.modalId = modalHashId;\nconst fullUrl = addHashToUrl(modalHashId);\nwindow.history.replaceState(null, \'\', fullUrl); // Use pushState to add a new entry in the history\n}\n},\ncloseModal: (modalHashId: `#${string}`, afterCloseCallBack?: SimpleFunction) => {\nif (currentModeRef.state === \'opening\') {\nif (window.location.hash === modalHashId) {\nif (afterCloseCallBack) {\ncurrentModeRef.onCloseCallback = afterCloseCallBack;\n}\ncurrentModeRef.state = \'closing\';\ncurrentModeRef.modalId = modalHashId;\nrouter.replace(path);\ncurrentModeRef.onCloseCallback?.();\n}\n}\n}\n};\n}\n\nexport const usePopStateListenerV2 = () => {\nconst params = useParams();\nuseEffect(() => {\nupdateModalState();\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, [params]);\n};\n19:05\nSchriften\nReact is split into two packages:\n\u2022 react: Implements the core features of the library\n\u2022 react-dom: Contains all the browser-related features\n19:29\nSchriften\nwe can extend interface with type and vice versa:\n\ninterface IWork {\ncompany: string\nposition: string\n}\ntype TPerson = IWork & {\nname: string\nage: number\n}\n20:54\nSchriften\nIn reply to this message\nThe react-dom package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside the React model if you need to. the important methods of react-dom:\nReactDOM.render() replaces the child of the given container if any. It uses a highly efficient diff algorithm and can modify any subtree of the DOM.\n\n- render(): This is one of the most important methods of ReactDOM. This function is used to render a single React Component or several Components wrapped together in a Component or a div element.\n\n- findDOMNode(): This function is generally used to get the DOM node where a particular React component was rendered. This method is very less used like the following can be done by adding a ref attribute to each component itself.\n\n- unmountComponentAtNode(): This function is used to unmount or remove the React Component that was rendered to a particular container.\n\n- hydrate(): This method is equivalent to the render() method but is implemented while using server-side rendering.\n\n- createPortal(): It allow us to render a component into a DOM node that resides outside the current DOM hierarchy of the parent component.\n\nReact\n\n- Whenever we use component, classes, elements, etc. We\u2019re using React\n  21:00\n  reactDom.render is deprecated and replaced with reactDom.createRoot((document.getElementById(\'root\')).render(<App/>)\n  because of these changes we could use new feats of react 18.\n  ReactDOM.hydrate(): In React 18, hydrate has been replaced by hydrateRoot(), which aligns with the createRoot() API.\n  3 September 2024\n  00:45\n  Schriften\n  the most important feat of react 18 is the Concurrent Rendering i think. it allows react to differ urgent and non-urgent task and allows browser to be interactive to user action event when some tasks are in process. this means rendering after setting a state wont block the thread and user is still able to click some btn and trigger an event.\n  to reach this we could use some hook like useTransition:\n\nimport React, { useState, useTransition } from \'react\';\nimport { createRoot } from \'react-dom/client\';\n\n// A component that generates a large list of numbers\nfunction SlowList({ count }) {\nconst items = [];\nfor (let i = 0; i < count; i++) {\nitems.push(<li key={i}>Item {i + 1}</li>);\n}\nreturn <ul>{items}</ul>;\n}\n\nfunction App() {\nconst [count, setCount] = useState(0); // Urgent state\nconst [listCount, setListCount] = useState(0); // Non-urgent state\n\n// Hook to manage transitions (non-urgent updates)\nconst [isPending, startTransition] = useTransition();\n\n// Handle button click - this is an urgent update\nconst handleButtonClick = () => {\nsetCount(count + 1); // Urgent update\n};\n\n// Handle list rendering - this is a non-urgent update\nconst handleSlowUpdate = () => {\nstartTransition(() => {\nsetListCount(5000); // Non-urgent update, can be deferred\n});\n};\n\nreturn (\n\n<div>\n<h1>Concurrent Rendering Example</h1>\n<button onClick={handleButtonClick}>\nIncrement Count (Urgent): {count}\n</button>\n<br />\n<button onClick={handleSlowUpdate} disabled={isPending}>\nRender Large List (Non-Urgent)\n</button>\n{isPending && <p>Loading...</p>}\n<SlowList count={listCount} />\n</div>\n);\n}\n\n// Render the App using createRoot (Concurrent mode enabled)\nconst root = createRoot(document.getElementById(\'root\'));\nroot.render(<App />);\n4 September 2024\n22:43\nSchriften\nenum in ts:\nwe can use them for keeping set of primative values:\n\nexport enum Status {\nIdle = \'IDLE\',\nLoading = \'LOADING\',\nSuccess = \'SUCCESS\',\nError = \'ERROR\',\n}\n\nconst [status, setStatus] = useState<Status>(Status.Idle);\n5 September 2024\n01:09\nSchriften\nnamespace:\nwe use them for grouping set of data togather and use them whrere needed:\n\nnamespace MyNamespace {\nexport const greeting = \'Hello, World!\';\n\nexport function sayHello() {\nconsole.log(greeting);\n}\n\nexport interface User {\nname: string;\nage: number;\n}\n}\n\n// Using the namespace\nMyNamespace.sayHello();\n14:48\nSchriften\nAdjacent JSX elements must be wrapped in an enclosing tag.\nwe must to wrap the multiple elements inside an element or fragment, cause jsx transpile to Js func and we can not retrun two funcs in js.\n23:22\nSchriften\nabout currying:\nwhen a func accept to params, we can convert it to accept only one param at the time and returning anohter func with the other param.\nwe could use this mehtod when we want to store a value and use it in different places. (when the first func called, the value is stored.)\n\nfunction name(x) {\nreturn (y) => x + y\n}\nconst b = name(1)\nb(2)\n///log 3\n//this method called currying\n//antoher way of calling this func:\nname(1)(2)\n6 September 2024\n01:54\nSchriften\nHOCs are functions that take a component as input and return an enhanced component as out-\nput\n\nconst withClassName = Component => props => (\n<Component {...props} className="my-class" />\n)\n20:37\nSchriften\nunctrolled and controlled comps (in form handling)\nwhen we let dom to handle value of an input and we just handle the changing of input to get the value in give it to submit. this method of handling is uncontrlled component, cause we have no controll on manging the value:\n\nconst [values, setValues] = useState({ firstName: \'\', lastName: \'\' })\nconst handleChange = ({ target: { name, value } }) => {\nsetValues({\n...values,\n[name]: value\n})\n}\n\nreturn (\n\n  <form onSubmit={handleSubmit}>\n    <input\n      type="text"\n      name="firstName"\n      onChange={handleChange}\n/> <input\n      type="text"\n      name="lastName"\n      onChange={handleChange}\n/>\n    <button>Submit</button>\n  </form>\n)\n20:40\nwhen we manage and controll the form value by using the state. in this mehtod we must expecitly add a value prop to the input element and set it to its related state:\n\nconst [values, setValues] = useState({ firstName: \'Carlos\', lastName:\n\'Santana\' })\n\nconst handleChange = ({ target: { name, value } }) => {\nsetValues({\n[name]: value\n})\n}\nconst handleSubmit = (e) => {\ne.preventDefault()\nconsole.log(`${values.firstName} ${values.lastName}`)\n}\n\nreturn (\n\n  <form onSubmit={handleSubmit}>\n    <input\n        type="text"\n        name="firstName"\n        value={values.firstName}\n        onChange={handleChange}\n/> <input\n        type="text"\n        name="lastName"\n        value={values.lastName}\n        onChange={handleChange}\n/>\n22:05\nSchriften\nevent handling and synthetic event in react:\nevents work differenet on various browser and react get and abstract these events and ease the developers event handling. because of that we could write event handlers that are unaware of the browser target.\nto do this react introduced the synthetic event. an obj that wrap the orginal rvent provided by browser with same props.\n\nmeans in react we dont have to use the window prrop eventListener. cause the events are catched in react and we could get them as a syntheticEvents prop.\n\nconst handleClick = (syntheticEvent) => {\n//nativeEvent is the browser native event and we could even reach it in react!\nconsole.log(syntheticEvent.nativeEvent instanceof MouseEvent)\nconsole.log(syntheticEvent.type === \'click\')\n//...\n}\n8 September 2024\n19:32\nSchriften\nevent pooling in react:\nin plain js when we create an eventHandler and use it for a btn onclick for example, this handler create a new event obj every time the btn clicked and this is heavy and talke a lot memory. so react create an cross-browser obj named synethetic event which wrappes around the event obj. when we create a handler and pass the event (syntetich event in here) to it, it calls and triggers the event. after the event finishes running it clears all the props of this obj to null and make it reusable for the next time.\nto prevent this event pooling we could use event.persist()\n\nimport React from \'react\';\n\nfunction EventPoolingExample() {\nconst handleClick = (event) => {\n//when we uncommet this we could persist the event obj\n// event.persist()\n// Here, React will pool the event after this function runs\nconsole.log(event.type); // Works here\nsetTimeout(() => {\n// The event properties will be cleared before this runs\nconsole.log(event.type); // Will likely be `null` or cause an error\n}, 1000);\n};\n\nreturn <button onClick={handleClick}>Click Me</button>;\n}\n\nexport default EventPoolingExample;\n\nEvent pooling has been deprecated in React 17+\n20:16\nSchriften\nevent delegation in react\nreact does not attach a listener in to each element and the func handlers will not directly call in react. instead react uses a top level event listener which has been set on the top of the project (document or root)\n\nimport React from \'react\';\n\nfunction List() {\nconst handleItemClick = (event) => {\nalert(`Item clicked: ${event.target.textContent}`);\n};\n\nreturn (\n\n<ul onClick={handleItemClick}>\n<li>Item 1</li>\n<li>Item 2</li>\n<li>Item 3</li>\n</ul>\n);\n}\n\nexport default Listt\n\nin this case when we click on one of the li, this click event bubble up to the dom, to that top level listenrer (the handler is not called yet). in this point react wrapps this event iside the ssynthetd event and starts to find the related elment then it calls its handler whith the correct syntetich event prop\n9 September 2024\n23:43\nSchriften\nan important difference between synthetic and native events is the performance.\nnative events might be set separatly in each element with a handler and these events are unique objs an have their specified space in memory and remains until garbage collection. instead\nSynthetic Events: Designed to optimize performance through pooling, reducing the number of objects created and saved in memory.\n18 September 2024\n00:08\nSchriften\nKey Functions of a Module Bundler in React\ncombining multiple files\nreducing browsers req by combinng modules/js or image or css resouces in to one bundle. code spliting and lazyLoading , tree shaking the dead code (when a huge lib imported but only one method used), transpliling, HMR (hot module replacement)\n\npopular react module bundlers:\nwebpack, parcel, vite , rollUp\n19 September 2024\n00:50\nSchriften\nhow webpack modulrize css:\nby default js has no idea about css codes but webpack turn(bundle) css to js module and inject it in to js module system. it does that helping loaders.\nthe most imprtant loader is:\ncss-loader: without it react doestnt understand import styles.css file in a component. css-loader tranform the css content (@import to require) to js module and export it as string and inject it to the dom.\n\nstyle-loader: this loader inject css to the dom via a <style> tag. its useful for dev mode because giving the reatime updating css changes but not recommended in production mode because of making bundle larger and preventthe caching css.\n\nmini-css-extract-plugin: this loader replaced with style-loader(production) and extarcats css from js in to separate .css file. this is important for production because it allows browser to load css in parrallel with js and cache it.\n\nin style-loader, css is embeded in to js and that make a huge bundle but because of this embeding it allows us a real-time css updates.\n\nso:\n\n- the css-loader is for bundling css file in to js\n- style-loader and mini-css-extract-plugin is for injecting css file to the dom. one in <style> tag and one in separate .css file.\n  00:55\n  in nextJS there is no need for webpack configurations because its already done and next use the webpack and the mentioned loaders undert the hood.\n  20 September 2024\n  13:23\n  Schriften\n  about vite the new module bundler:\n  an important difference is the way of handling modules on dev. older bundler like webpack must bundle and build the whole app before serving it on server on dev env. but vite deosnt bundle anything on dev, it serves files as es moudle and when something changes it update and reload only that file and its deps making HMR faster.\n  on production vite use Rollup module bundler under the hood.\n  7 October 2024\n  21:03\n  Schriften\n  concurent mode in react\n  rendering in tradtional react was sync and happend in a single theread but in react 18 rendering is splitted to smaller unit of work and each part can process in parallel.\n  React can prioritize certain tasks, such\n  as updating the user interface, while still allowing other tasks to run in the background, such as\n  handling user input or fetching data.\n\n#there\n9 October 2024\n18:53\nSchriften\nRendering and hydration in react 18\nrendering is the proccess of converting react compoennt to dom element and displaying it on screeen.\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'),)\nroot.render(<App />)\n\nhydration is the attaching event listenders and handlers to the already rendered from server in client and making the ssred comp interactive.\n\nconst root = createRoot(document.getElementById(\'root\'))\nhydrateRoot(document.getElementById(\'root\'), <App />)\n10 October 2024\n00:29\nSchriften\nrenderToPipeableStream\nits another ss method in react 18. instead if rendering all the html content and then send it to the client, this method allows us to render content part by part and send it part by part to the client.\nhis means the browser can start displaying the page\'s content bit by bit, improving the user experience.\nOnce the full HTML is rendered and sent, React can take over on the client side to "hydrate" the app, attaching event listeners and making the page interactive.\n\nimport { renderToPipeableStream } from \'react-dom/server\';\nimport App from \'./App\'; // Your main React component\n\nconst server = require(\'http\').createServer((req, res) => {\n// Start streaming the React app as HTML\nconst stream = renderToPipeableStream(<App />, {\nonShellReady() {\n// Pipe the stream to the response (send HTML to the browser)\nstream.pipe(res);\n},\nonError(err) {\nconsole.error(err);\n}\n});\n});\n\nserver.listen(3000);\n00:59\nSchriften\nuseDeferredValue: It doesn\'t explicitly limit the rate at which updates happen. Instead, it defers the value update until the UI has finished rendering more critical updates. It allows React to prioritize rendering the essential parts of the UI first, while deferring the less urgent updates, making the UI more responsive.\n\nimport { useState, useTransition, useDeferredValue } from \'react\';\n\nfunction SearchComponent({ items }) {\nconst [query, setQuery] = useState(\'\');\nconst [isPending, startTransition] = useTransition(); // useTransition hook\nconst deferredQuery = useDeferredValue(query); // useDeferredValue hook\n\n// Handle input changes using a transition to avoid blocking UI\nconst handleInputChange = (e) => {\nconst newValue = e.target.value;\nstartTransition(() => { // Marking the update as low priority\nsetQuery(newValue);\n});\n};\n\n// Filtering the items using the deferred value to make sure the UI remains responsive\nconst filteredItems = items.filter(item => item.includes(deferredQuery));\n\nreturn (\n\n<div>\n<input\n        value={query}\n        onChange={handleInputChange}\n        placeholder="Search..."\n      />\n\n      {/* Show loading state when the transition is pending */}\n      {isPending ? <p>Loading...</p> : null}\n\n      <ul>\n        {filteredItems.map(item => (\n          <li key={item}>{item}</li>\n        ))}\n      </ul>\n    </div>\n\n);\n}\n01:09\nuseInsertionEffect is run right after the element is inserted to a dom its like useEffect and layoutEffect but it runs beofre them:\n1- run useInsertionEffect - called before any dom updates after JSX transpilation\n2- run useLayoutEffect - called after dom updated and before paitned\n3- run useEffect - called async after dom updated and painted\n28 October 2024\n18:57\nSchriften\nabout concurrent rendering:\nThe fact that a typical state update blocks the main task is what Concurrent Rendering aims to combat. With it, we can explicitly mark some state updates and the re-rendering caused by them as "non-critical"\n\nAs a result, React will calculate these updates in the "background" instead of blocking the main task. If something "critical" happens (i.e., a normal state update), React will pause its "background" rendering, execute the critical update, and then either return to the previous task or abandon it completely and start a new one.\n19:03\nuseTransition , deferredValue, or suspence is two other ways of concurret rendering\n\nexport default function App() {\nconst [tab, setTab] = useState(\'issues\');\n\n// add the useTransition hook\nconst [isPending, startTransition] = useTransition();\n\nreturn (\n\n<div className="container">\n<div className="tabs">\n...\n<TabButton\n// indicate that the content is loading\nisLoading={isPending}\nonClick={() => {\n// call setTab inside a function\n// that is passed to startTransition\nstartTransition(() => {\nsetTab(\'projects\');\n});\n}}\nname="Projects"\n/>\n...\n</div>\n...\n</div>\n);\n}\n29 October 2024\n23:34\nSchriften\nabout useTransition and its downSilded\nhttps://www.developerway.com/posts/use-transition\n30 October 2024\n21:26\nSchriften\nabout throttle in js and react:\nsimple explaination is: throttle specified how many time can a func be called in a specific time. i,e when we set a dely to 1 sec, the func can be called only one sec after its last call no matter how many time we trigger it.\nin js:\n\nfunction throttle(cb, delay) {\nlet lastCall = 0;\n\nreturn function (...args) {\nconst now = new Date().getTime();\nif (now - lastCall >= delay) {\nlastCall = now;\nreturn cb(...args);\n}\nreturn null;\n};\n}\n\nthrottle in react as a hook:\n\nfunction useThrottle(cb, delay) {\nconst lastCall = useRef(0);\n// also you can create another ref and pass the simple func wuth args to the current method of i\n// instead of useCallBack\nconst throttledCB = useCallback(\n(...args) => {\nconst now = new Date().getTime();\n\n      if (now - lastCall >= delay) {\n        lastCall.current = now;\n        return cb(...args);\n      }\n      return null;\n    },\n    [cb, delay]\n\n);\n\nreturn throttledCB;\n}\n31 October 2024\n16:50\nSchriften\nabout debounce:\ndebounce lets us to call a func after user stops an action and the time has reached to the sepecified dely.\nin throtteling the time is fixed we set a delay and the func will be called after the delay is over no matter if the user is still in action or not. but in debouncing, the time is reset after each user actions and the func never be called unless user stops trigerring the action and the time reached to delay.\n\ndeboincing in JS\n\nfunction debounce(cb, delay) {\nlet timer;\nreturn function (...args) {\nclearTimeout(timer);\ntimer = setTimeout(() => {\ncb(...args);\n}, delay);\n};\n}\n\ndebouncing in react:\n\nfunction useDebounce(cb, delay) {\nconst timeoutRef = useRef(0);\nconst debouncedFunc = useCallback(\n(...args) => {\nif (timeoutRef.current) {\nclearTimeout(timeoutRef.current);\n}\n\n      timeoutRef.current = setTimeout(() => {\n        cb(...args);\n      }, [delay]);\n    },\n    [delay, cb]\n\n);\nreturn debouncedFunc;\n}\n16:54\n\ud83d\udc46 throttle vs debounce for last fuckin time \ud83d\udc46\n1 November 2024\n01:43\nSchriften\ndo performant animgation.\navoid using css pops in animating which trigger painitng or layout. we can experiment that by chrome dev tools. performance tap, record and see the rendering percentage and animation frame.\nwe must always use transform or opacity related props. something other than them should use very carrefully because of paint and layout triggering.\n01:43\nThese four steps are known as the browser\'s rendering pipeline.\n1- Style: Calculate the styles that apply to the elements.\n2- Layout: Generate the geometry and position for each element.\n3- Paint: Fill out the pixels for each element into layers.\n4- Composite: Draw the layers to the screen.\n01:58\nCSS vs JavaScript performance\nYou might wonder: is it better from a performance perspective to use CSS or JavaScript for animations?\n\nCSS-based animations, and Web Animations (in the browsers that support the API), are typically handled on a thread known as the compositor thread. This is different from the browser\'s main thread, where styling, layout, painting, and JavaScript are executed. This means that if the browser is running some expensive tasks on the main thread, these animations can keep going without being interrupted.\n\nAs explained in this article, other changes to transforms and opacity can, in many cases, also be handled by the compositor thread.\n\nIf any animation triggers paint, layout, or both, the main thread will be required to do work. This is true for both CSS and JavaScript animations\n\nhttps://web.dev/articles/animations-overview\n02:01\ntransorm and opacity animations affect composite step and take less works agains width or heitg or top or bottom which are a layout related props\n20:04\nSchriften\nabout will-change in css:\n\n- this property can be used in situations when an animated element will be repated constantly or regulary.\n- with setting that we\'re teling the browser that the element will change soon so it keeps the optimization of the animation for next time.\n\nin fact,\n\n- by default browser makes for transform and opacity a new layer and remove it automatically by ending the process.\n- with will-change , after an animation accures, browser create and persist a new rendering layer.\n- thats why we should use thi prop carefully. it creats and keep new layer for each element with this prop\n- creating too many layers can cause performace issues.\n- with will-change we could persist the animation-transtion layer\n  3 November 2024\n  23:05\n  Schriften\n  About react router\n\nBrowserRouter sets up the application\'s navigation context, while Route defines individual routes, and Switch ensures only one route is rendered at a time\n23:22\nSchriften\nAbout routGuard\n\n// In a component\nimport { Route, Redirect } from \'react-router-dom\';\n\nfunction PrivateRoute({ children, isAuthenticated }) {\nreturn (\n<Route\nrender={({ location }) =>\nisAuthenticated ? (\nchildren\n) : (\n<Redirect to={{ pathname: \'/login\', state: { from: location } }} />\n)\n}\n/>\n);\n}\n23:24\nTo handle 404 err in react, we add a Route comp without any path prop and a component prop with 404 content.\n\nimport { Route, Switch } from \'react-router-dom\';\n\nfunction\n\nNotFound() {\nreturn <h2>404 - Not Found</h2>;\n}\n\nfunction App() {\nreturn (\n<Switch>\n{/_ Other routes _/}\n<Route component={NotFound} />\n</Switch>\n);\n}\n4 November 2024\n01:17\nSchriften\nabout loader in react router 6.4\nit allows us to fetch and load data without using useEffect. we create a loaderData func and pass it to the Route comp of the related page and then inside the page comp we use the useLoaderData to receive the fetched data. with useNavigation hook we can get a pending state before getting the res from useLoader data:\n\npage 218 / 189 of React_18 design pattern\n5 November 2024\n00:18\nSchriften\nabout react router 6.4 feats:\n\n- client side routing: instead of requesting the server to get a new document and load assets - css on every route navigations, it allows us to update url without sending another req for another document.\n- nested routes with createBrowserRouter and createRoutesFromElements:\n\ncreateBrowserRouter(\ncreateRoutesFromElements(\n<Route path="/" element={<Root />}>\n<Route path="contact" element={<Contact />} />\n<Route\npath="dashboard"\nelement={<Dashboard />}\nloader={({ request }) =>\nfetch("/api/dashboard.json", {\nsignal: request.signal,\n})\n}\n/>\n<Route element={<AuthLayout />}>\n<Route\npath="login"\nelement={<Login />}\nloader={redirectIfUser}\n/>\n<Route path="logout" action={logoutUser} />\n</Route>\n</Route>\n)\n);\n\n- getting dynamic parameter in routhe with useMatch\n- NavLink allows us to create a navigaton bar and differ the acitve inactive routes:\n\n<NavLink\nstyle={({ isActive, isPending }) => {\nreturn {\ncolor: isActive ? "red" : "inherit",\n};\n}}\nclassName={({ isActive, isPending }) => {\nreturn isActive ? "active" : isPending ? "pending" : "";\n}}\n/>\n\n- data fetching with using loader prop inside the Route comp and get the fetched data inside the page comp with useLoaderData\n- pending status with useNavigation when using the loader in the way that the data for the next page will loaded before the new page is rendered.\n\nfunction Root() {\nconst navigation = useNavigation();\nreturn (\n\n<div>\n{navigation.state === "loading" && <GlobalSpinner />}\n<FakeSidebar />\n<Outlet />\n<FakeFooter />\n</div>\n);\n}\n\n- pending status with defer method - Suspense and the Await comp inside it in the way that loading data for the new page is after entering inside it:\n\n<Route\npath="issue/:issueId"\nelement={<Issue />}\nloader={async ({ params }) => {\n// these are promises, but _not_ awaited\nconst comments = fake.getIssueComments(params.issueId);\nconst history = fake.getIssueHistory(params.issueId);\n// the issue, however, _is_ awaited\nconst issue = await fake.getIssue(params.issueId);\n\n    // defer enables suspense for the un-awaited promises\n    return defer({ issue, comments, history });\n\n}}\n/>;\n\nfunction Issue() {\nconst { issue, history, comments } = useLoaderData();\nreturn (\n\n<div>\n<IssueDescription issue={issue} />\n\n      {/* Suspense provides the placeholder fallback */}\n      <Suspense fallback={<IssueHistorySkeleton />}>\n        {/* Await manages the deferred data (promise) */}\n        <Await resolve={history}>\n          {/* this calls back when the data is resolved */}\n          {(resolvedHistory) => (\n            <IssueHistory history={resolvedHistory} />\n          )}\n        </Await>\n      </Suspense>\n\n.\n.\n.\n\n- race condtion handlng: when a async taske starts before another new task but resolve after that. this results the ui shows the wrong state.\n  react router wont let this issue occurs. it cancel the async task after starting new task which changes the state:\n\n?q=ry |---------------|\n^ commit wrong state (which can be canceled by react router system)\n?q=ryan |--------|\n^ lose correct state\n\n- err handling: react handles err in rendering, laoding data. but not err realted to hooks or event handlers. react handle the two mentioned err with errorElement prop inside the Route comp. if the comp doesnt have one, the err bubble up to first parent route with that prop.\n- scroll preserving with ScrollRestoration comp\n- get loaction props of the winodw with useLocation. also we can add some state to link with specifice path and get that state with this hook:\n`\nfunction App() {\nconst navigate = useNavigate();\n00:18\nreturn (\n<>\n<Link to="/home" state={{ someValue: "example" }}>\nGo to home page with state\n</Link>\n<button\nonClick={() =>\nnavigate("/home", {\nstate: { someValue: "example" },\n})\n}\n>\nGo to home page with state\n</button>\n</>\n);\n}\n\n`\n6 November 2024\n18:08\nSchriften\n{\nvar name = "mohsen";\n}\nconsole.log(name);\n\nvar name = "test"\n\nconst cars = ["bmw", "mercedes"];\ncars[0] = "ford"\n\nconst name = "fabod";\nname[0] = "\\_"\n\npromise(() => {\nsettimeout(() => {\nconsole.log("s1");\n}, 0)\n});\n\nsettimeout(() => {\nconsole.log("s2");\n}, 0)\n\npromise(() => {\nconsole.log("p1");\n});\n\nfarbod deylami, 5:35 PM\n\n<div>\n<button />\n</div>\n\nsnapp interview\n13 November 2024\n13:03\nSchriften\nhttps://codesandbox.io/p/sandbox/interview-forked-m2x7y6?file=%2Fsrc%2FApp.tsx%3A1%2C1-78%2C1\ntimer challange\n\nimport React, { useState, useEffect, useRef } from "react";\n\nfunction Timer() {\nconst time = useRef(50);\nvar [counter, setCounter] = useState(0);\nconst [laps, setLaps] = useState([]);\n\nconst timer = useRef();\n\nuseEffect(function () {\nlet sec = counter;\n// Start the timer automatically on mount (not ideal)\ntimer.current = setInterval(function () {\nsec += 1;\nsetCounter(sec); // Wrong way of managing state\n}, 1000);\n\n    return function () {\n      clearInterval(timer.current); // Not properly clearing the interval\n    };\n\n}, []);\n\nfunction startTimer() {\nif (!timer.current) {\nlet sec = counter;\ntimer.current = setInterval(function () {\nsec += 1;\nsetCounter(sec);\n}, 1000);\n}\n}\n\nfunction stopTimer() {\nclearInterval(timer.current); // This won\'t stop the timer correctly\ntimer.current = null;\n}\n\nfunction resetTimer() {\ntime.current = 0;\nsetCounter(0);\nsetLaps([]); // This doesn\'t trigger a re-render for laps\nstopTimer();\n}\n\nfunction addLap() {\nsetLaps((prev) => [...prev, counter]);\n}\n\nfunction getTime(counter) {\nconst hrs = Math.floor(counter / 3600);\nconst mins = Math.floor((counter % 3600) / 60);\nconst secs = counter % 60;\n\n    const formattedHrs = String(hrs).padStart(2, "0");\n    const formattedMins = String(mins).padStart(2, "0");\n    const formattedSecs = String(secs).padStart(2, "0");\n\n    return `${formattedHrs}:${formattedMins}:${formattedSecs}`;\n\n}\n\nreturn (\n\n<div>\n<h1>Timer: {getTime(counter)} seconds</h1>\n<button onClick={startTimer}>Start</button>\n<button onClick={stopTimer}>Stop</button>\n<button onClick={resetTimer}>Reset</button>\n<button onClick={addLap}>Lap</button>\n<div>\n{laps?.map((lap) => (\n<div>{lap}</div>\n))}\n</div>\n</div>\n);\n}\n\nexport default Timer;\n18 November 2024\n23:16\nSchriften\nreact security in xss attack (script injecting)\nin react we use curly braces to add js in to the markup. injected script behaves like simple string in jsx before rendering in dom:\n\nconst userInput = "<script>alert(\'XSS\')<\/script>";\n// this injected script wont execute in react and jsx turns it to a string and send it to the dom.\nreturn <div>{userInput}</div>;\n23:25\nabout dangerouslySetInnerHTML\nwhen we use this prop, react wont scape from executing script and an xss attack is possible by using it. this prop, direcly inject html to the dom and it might contains some malicous script in it.\n\nreturn <div dangerouslySetInnerHTML={{ __html: comment }}></div>;\n\ntherefor when we must use it, its safer to sanitize the prop value. sanitizing the content could remove all possible dangerous code like script, onError, iFrame ...\nwe could do that my libs like domPurify or sanitize-html.\n19 November 2024\n00:30\nSchriften\nabout CSRF:\nCross-Site Request Forgery.\ntricks an authenticated user into unknowingly submitting a request to a web application they are logged into, but from a different origin (e.g., a malicious website). This allows the attacker to perform actions on behalf of the user, such as:\n\n- Changing account settings\n- Transferring funds\n- Deleting data\n\nhow to prevent:\nsame origin policy. every origin is defined by 3 methods:\n\n- Scheme (e.g., http or https)\n- Host (e.g., example.com)\n- Port (e.g., 80, 443)\n  urls have same origing if all these 3 are the same. same origin policy prevent the attecker req to get and read res from the attecked site.\n\nanother way of prevent CSRF attack is setting a CSRF token in back and hiding it in the forms as input and send it again by submission. the server can check if both sent and received tokens are the same or not.(with this impelementation, attacker can not read csrf token and his req is not valid in server.)\n23 November 2024\n20:11\nSchriften\nhow binary search works:\n\nfunction binarySearchSteps(totalItems) {\n// if (totalItems <= 0) {\n// return 0;\n// }\n// let count = 1;\n// while (totalItems > 1) {\n// totalItems = Math.floor(totalItems / 2);\n// count++;\n// }\n// return count;\n//or :\nreturn Math.ceil(Math.log2(totalItems));\n}\n27 November 2024\n00:03\nSchriften\nLinear and logarithmic time.\n\nWhen the max numbers of each search is the same as size of the list. This is called linear time.\nBut if the numbers of each search is based on how many times can the list be divided to 2 , its called log time or logarithmic time.\n28 November 2024\n19:11\nSchriften\nabout big 0 notaion:\nit tells us how fast an algourthm is. big o is not about how much time will take that an alogorthm reaches the result, its about how many operations will take that an algorithm reaches to the result.\nin simple search in a list of n items it takes O(n) operation (worst case)\nin binary search in list of n items it takes O(log n) operations.\n29 November 2024\n03:04\nSchriften\nIn reply to this message\nfactorial time O (n!)\nthis is a terrible and a low running alg which there is no alternative solution for it.\nthe travleing saleperson who wants to travel to 5 cities and wants to find the shortest route for travelling to all of them.\n\nfunction salePerson(citesAmount) {\nlet result = citesAmount;\nlet remain = citesAmount - 1;\nwhile (remain > 1) {\nresult _= remain;\nremain--;\n}\nreturn result;\n// return citesAmount <= 1\n// ? 1\n// : (citesAmount = citesAmount _ salePerson(citesAmount - 1));\n}\n21 December 2024\n20:46\nSchriften\nabout SW:\nA service worker is a bit like a proxy server between the application and the browser, and it has quite a bit of power. With a service worker, we can completely take over the response from an HTTP request and alter it\n3 January 2025\n19:49\nSchriften\nregular import statement and import(\'/dir\') :\nfirst one load the comp in compile time and the sec one loads it on demand / on run time (layzy loading)\n21:15\nSchriften\nAbout CI - CD:\ncontinues integration: a service that make changes be tested and build automatically. It helps to speed up tests and build for safer deploy by ensuring that the new changes won\u2019t break the codebase.\nCD: continues deployment: automatically deploys your react app on production or staging env if the CI pipeline is passed.\nFor this service we need: version control system like gitlalb - CI-CD service like GitHub actions , circle CI , Jenkins - deployment platform: verbal - firebase or custom servers.\n\nwe need to create a workflow in the project, its a .yml file based on version control . In the file we manage what command (build , liners \u2026) run and when they run (after push or merge some changes in demo or master\n20 January 2025\n20:59\nSchriften\nInfinity in js:\nits type is number. we use it sometimes to initalize a variable with a number that is definitly bigger than any future nums that goining to be assigned to the varibale.\ni.e Infinity ensures that any future re-asigining number will be shorter that our current reasigned num (which is infinity).\n21 January 2025\n22:45\nSchriften\ndijkstra alg\n\n- make a store for distances , visited nodes , parent nodes, proccessing nodes\n- initialize distances and parent: parent with null and distances with infinity\n- reasigning first node distance to 0\n\n- find the closest unvisited node\n- update its neighbors distances\n- find the next closest unvisited node...\n\n- find the fastest path by backtracking through parents.\n\nconst graph = {\nSTART: { A: 6, B: 2 },\nA: { FIN: 1 },\nB: { A: 3, FIN: 5 },\nFIN: {},\n};\nfunction dijkstra(graph, start, end) {\nconst distances = {};\nconst visited = new Set();\nconst previous = {};\nconst nodes = new Set(Object.keys(graph));\n\n// Initialize distances and previous\nnodes.forEach((node) => {\ndistances[node] = Infinity;\nprevious[node] = null;\n});\ndistances[start] = 0;\n\nwhile (nodes.size > 0) {\n// Get the closest unvisited node\nlet currentNode = null;\nnodes.forEach((node) => {\nif (\n!visited.has(node) &&\n(currentNode === null || distances[node] < distances[currentNode])\n) {\ncurrentNode = node;\n}\n});\n\n    if (currentNode === null || distances[currentNode] === Infinity) {\n      break; // No reachable nodes left\n    }\n\n    // Mark as visited\n    nodes.delete(currentNode);\n    visited.add(currentNode);\n\n    // Update distances to neighbors\n    const neighbors = graph[currentNode];\n    for (let neighbor in neighbors) {\n      const newDistance = distances[currentNode] + neighbors[neighbor];\n      if (newDistance < distances[neighbor]) {\n        distances[neighbor] = newDistance;\n        previous[neighbor] = currentNode;\n      }\n    }\n\n}\n\n// Backtrack to find the shortest path\nconst path = [];\nlet current = end;\nwhile (current !== null) {\npath.unshift(current);\ncurrent = previous[current];\n}\n\nif (path[0] !== start) {\nreturn { path: null, distance: Infinity }; // No path found\n}\n\nreturn { path, distance: distances[end] };\n}\n\n// Run the algorithm\nconst result = dijkstra(graph, "START", "FIN");\nconsole.log(Shortest path: ${result.path.join(" -> ")});\nconsole.log(Shortest distance: ${result.distance});\n23 January 2025\n13:06\nSchriften\nabout useEffect hook:\nAccording to the react documentation, the callback should either return nothing (undefined) or return a cleanup function.\n14:12\nSchriften\nwhy use reqeutAnimationFrame:\n\nthis func takes a callback and call it after each frame render. so this func make updates happen based on browser refresh rate (60 fps) and sync updates with browser rendering cycle and avoid redundant updates in each frame.\n\nimport React, { useState, useEffect, useRef } from \'react\';\n\nconst ScrollPosition = () => {\nconst [scrollY, setScrollY] = useState(0);\nconst ticking = useRef(false);\n\nuseEffect(() => {\nconst handleScroll = () => {\nif (!ticking.current) {\nticking.current = true;\nrequestAnimationFrame(() => {\nsetScrollY(window.scrollY);\nticking.current = false;\n});\n}\n};\n\n    // Attach the scroll event listener\n    window.addEventListener(\'scroll\', handleScroll);\n\n    // Cleanup the event listener on unmount\n    return () => {\n      window.removeEventListener(\'scroll\', handleScroll);\n    };\n\n}, []);\n\nreturn (\n\n<p>Scroll Y Position: {scrollY}px</p>\n);\n};\n\nexport default ScrollPosition;\n\n- the callback called before browser renders the next frame.\n- it exactly call before paint process\n- The requestAnimationFrame callback is scheduled after JavaScript execution but before rendering starts.\n- This timing ensures:\n  Any DOM or CSS updates you make in the RAF callback are applied before the next frame is painted.\n  There\u2019s no unnecessary reflows or repaints between frames, leading to optimal performance.\n\nthen the requestAnimationFrame calls before painting and get ready the update in callback and then gives the update to next render(frame)\n14:32\nSchriften\nreqeutAnimationFrame runs after all microtasks have been processed and before the browser repaints the screen. then its MacroTask\n19:15\nSchriften\nstopImmediatePropagation()\nThe event.stopPropagation() stops the event from going to the next element. All handlers associated with the current element for that particular event will still get executed. This does not happen in event.stopImmediatePropagation() where propagation stops immediately, and no event handlers execute even if they belong to the current element.\n19:18\neventprogations:\nwhen event is triggered , event passed from root down to the target element (capturing)\nevent reach to target and be executed (targetting)\nevent bubble up and all event in the way be executed (bubbling)\n19:36\nSchriften\nabout this in event listenders:\nWhen used in event listeners, this refers to the element that triggered the event.\nin general this reffers to the surrending lexical scope.\n\nconst button = document.querySelector(\'button\');\nbutton.addEventListener(\'click\', function() {\nconsole.log(this); // Refers to the button element\n});\n24 January 2025\n02:21\nSchriften\nstrict mode:\n\n- gives err when create unasigned value : x = 2\n- gives err when we use this.val and val is not in the lexical scope\n- cant assigned prop to a non-writable obj\n\nconst obj = {};\nObject.defineProperty(obj, \'x\', { value: 42, writable: false });\nobj.x = 10; // Throws TypeError in strict mode\n\nit prevents silent errs like these to be ignored\nit makes code more constant and predictible and hepls debugging\n\nstrict mode applies these rules in parsing. the js engine v8 or spidermonky parses codes and turns them in to AST in AST some stricter rules check the code for any dangers.\nafter parsing strict mode transfer these issues in runtime.\n20:03\nSchriften\nabout obj decriptors:\n\nObject.defineProperty(obj, "key", {\n// Getter for \'key\' this func will run when we want access to key prop: obj.key\nget: function () {\nreturn this.\\_key || "Default Value"; // Return the value of \'\\_key\' or a default if not set\n},\n\n// Setter for \'key\' this func will run when we want access to key prop: obj.key\nset: function (value) {\nif (typeof value === "string") {\nthis.\\_key = value.trim(); // Validate and trim the value before setting\n} else {\nconsole.error("Invalid value. \'key\' must be a string.");\n}\n},\n\nenumerable: true, // Makes the property show up during enumeration (e.g., in `for...in`)\nconfigurable: true // Allows the property to be redefined or deleted\n});\n25 January 2025\n20:22\nSchriften\nreact reconcilition and diffing alg:\nreact in every state changes creates a new v dom and compares it with old to update r dom in exact location of change. this is called reconcilation. the way react does it is diffing alg:\nin diffing alg: if the root element type is changed -div => p react destory old tree and replaces with new tree. if the elment didint change react update its props.\nreact only compares the nodes at the same level- o(n) and not compares eveny nodes pair o(n2).\nbased on comparing node on the samce level react makes some assumtions if update or use old instance.\n21:01\nSchriften\nselection sort o(n2)\n\nfunction findSmallest2(arr) {\nlet smallest = arr[0];\nlet idx = 0;\nfor (let i = 1; i < arr.length; i++) {\nif (arr[i] < smallest) {\nsmallest = arr[i];\nidx = i;\n}\n}\nreturn idx;\n}\nfunction selectionSort(arr) {\nlet sortedArr = [];\nwhile (arr.length > 0) {\nfor (let i = 0; i < arr.length; i++) {\nconst smallest = findSmallest2(arr);\nsortedArr.push(arr[smallest]);\narr.splice(smallest, 1);\n}\n}\nconsole.log(sortedArr);\n}\nselectionSort(array2);\n\nselection sort another:\n\nfunction selectionSort(arr) {\nfor (let i = 0; i < arr.length; i++) {\nlet minIndex = i;\nfor (let j = i + 1; j < arr.length; j++) {\nif (arr[j] < arr[minIndex]) minIndex = j;\n}\nif (minIndex !== i) [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n}\n\nconsole.log(arr);\n}\n21:22\nSchriften\nquick sort\n\nfunction quickSort(arr) {\nif (arr.length < 2) {\nreturn arr;\n}\n// choose the middleItm as pivot\nlet pivotIdx = Math.floor(arr.length / 2);\nlet pivot = arr[pivotIdx];\nlet left = [];\nlet right = [];\nfor (let i = 0; i < arr.length; i++) {\nif (i === pivotIdx) continue;\nif (arr[i] > pivot) {\nright.push(arr[i]);\n} else {\nleft.push(arr[i]);\n}\n}\nreturn [...quickSort(left), pivot, ...quickSort(right)];\n}\n21:36\nbinarySearch:\n\nfunction binary(arr, itm, low, high) {\n// let low = 0;\n// let high = arr.length - 1;\n// while (low <= high) {\n// let mid = Math.round(high + low / 2);\n// let guess = arr[mid];\n// if (itm === guess) {\n// return mid;\n// } else if (itm > guess) {\n// low = mid + 1;\n// } else {\n// high = mid - 1;\n// }\n// }\n// return "none";\n\n// recursive way:\nif (low > high) {\nreturn "NONE";\n}\nlet mid = Math.floor((low + high) / 2);\nlet guess = arr[mid];\nif (itm === guess) {\nreturn mid;\n} else if (itm > guess) {\nreturn binary(arr, itm, mid + 1, high);\n} else {\nreturn binary(arr, itm, low, mid - 1);\n}\n}\n22:32\nSchriften\na simple usage of arr.reducre \ud83d\ude2c\n\nconst numbers = ["a", "b", "a", "b", "c", "d", "c"];\nconst sums = numbers.reduce((accumulator, currentValue) => {\nif (accumulator[currentValue]) {\naccumulator[currentValue]++;\n} else {\naccumulator[currentValue] = 1;\n}\nreturn accumulator;\n}, {}); // initValue of the accumulator\n\n// { a: 2, b: 2, c: 2, d: 1 }\n\nor\n\nconst numbers = [1, 2, 3, 4, 5];\nconst sums = numbers.reduce((accumulator, currentValue) => {\nreturn accumulator + currentValue;\n}); // Initial value is 0\n27 January 2025\n23:27\nSchriften\n\n- we have 5 radio stations\n- we want to start a show and we want to reach to the listeners in 10 states\n- each station can cover multiple states and the states could overlap\n\ngreedy solution:\n\n- find the station that covers states that haven\'t been covered\n- repeat till all 10 states are covered\n\nconst statesNeeded = new Set([\n"WA",\n"OR",\n"ID",\n"NV",\n"UT",\n"CA",\n"AZ",\n"MT",\n"CO",\n"NM",\n]);\nconst stations = {\nstation1: new Set(["ID", "NV", "UT", "CO"]),\nstation2: new Set(["WA", "ID", "MT"]),\nstation3: new Set(["OR", "NV", "CA"]),\nstation4: new Set(["CA", "AZ", "NM"]),\nstation5: new Set(["CO", "UT", "NM"]),\n};\nfunction greedySetCover(statesNeeded, stations) {\nconst selectedStations = new Set();\n\nwhile (statesNeeded.size > 0) {\nlet bestStation = null;\nlet statesCovered = new Set();\n\n    for (const [station, states] of Object.entries(stations)) {\n      const covered = new Set(\n        [...states].filter((state) => statesNeeded.has(state))\n      );\n\n      if (covered.size > statesCovered.size) {\n        bestStation = station;\n        statesCovered = covered;\n      }\n    }\n    selectedStations.add(bestStation);\n    statesCovered.forEach((state) => statesNeeded.delete(state));\n\n}\n\nreturn selectedStations;\n}\n\nconst result = greedySetCover(statesNeeded, stations);\nconsole.log({ result });\n29 January 2025\n11:11\nSchriften\n\u0645\u0635\u0627\u062d\u0628\u0647*\u0641\u0631\u0627\u0646\u062a*\u0627\u0646\u062f*\u062f\u06cc\u0648\u0627\u0631*\u06f1\u06f4\u06f0\u06f2*\u062a\u063a\u06cc\u06cc\u0631*\u0633\u0627\u062e\u062a\u0627\u0631*\u0627\u0637\u0644\u0627\u0639\u0627\u062a.pdf\nNot included, change data exporting settings to download.\n420.4 KB\n11:11\n\u0645\u0635\u0627\u062d\u0628\u0647*\u0641\u0631\u0627\u0646\u062a*\u0627\u0646\u062f*\u062f\u06cc\u0648\u0627\u0631*\u06f1\u06f4\u06f0\u06f2*\u062c\u0633\u062a\u062c\u0648*\u0645\u06cc\u0627\u0646*\u0627\u0633\u0627\u0645\u06cc.pdf\nNot included, change data exporting settings to download.\n255.8 KB\n6 February 2025\n20:45\nSchriften\nin programming arr or str are zero-based-indexed but in dynamic programming we\'re creating grids and we should consider in DP arrays are one-based inexed:\nthe LCS soultuion in DP:\n\nfunction longestCommonSubstrDP(s1, s2) {\nlet m = s1.length;\nlet n = s2.length;\n\n// Create a 1D array to store the previous row\'s results\nlet prev = new Array(n + 1).fill(0);\n\nlet res = 0;\nfor (let i = 1; i <= m; i++) {\n// Create a temporary array to store the current row\nlet curr = new Array(n + 1).fill(0);\nfor (let j = 1; j <= n; j++) {\nif (s1[i - 1] === s2[j - 1]) {\ncurr[j] = prev[j - 1] + 1;\nres = Math.max(res, curr[j]);\n} else {\ncurr[j] = 0;\n}\n}\n\n    // Move the current row\'s data to the previous row\n    prev = curr;\n\n}\n\nreturn res;\n}\n\n// Driver Code\nlet s1 = "";\nlet s2 = "ggeegeeksquizpractice";\nconsole.log(longestCommonSubstrDP(s1, s2));\n8 February 2025\n21:14\nSchriften\nflat arr with array.reduce:\n\nconst myArr = [\n[1, 2],\n[3, 4],\n[5, 6],\n];\n\nfunction makeFlat(arr) {\nreturn arr.reduce((acc, curr) => {\nif (Array.isArray(curr)) {\nacc.push(...curr);\n}\nreturn acc;\n}, []);\n}\n\nwith while loop:\n\nfunction makeFlat(arr) {\nconst simpleArr = [];\nlet i = 0;\n\nwhile (i < arr.length) {\nsimpleArr.push(...arr[i]);\ni++;\n}\nreturn simpleArr;\n}\n22:22\nSchriften\nif we difine a variable without any syntactx it becomes an implicit global varibale and we could access to it event if its difined in a functional scope. a varibale with var does not like this and if defined in fuincion scope its accecible only there:\n\nfunction test() {\nx = 10; // \u274c No var/let/const -> Becomes a global variable!\n}\ntest();\n\nconsole.log(x);\n22:24\nif a varibale difned with var in a non-functional scope it becomes a direct winow obj varibale.\n22:24\nabout var let const \ud83d\udc46\n22:43\nSchriften\nlong running task like, cpu-intesive taske, fs.readfile, mirotaskst and the eventLoop it self in node env are handled(offloaded to) with Libouv:\nSince there\'s no browser in a Node.js environment.\nA C++ library that powers Node.js\u2019s async operations.\n17 February 2025\n21:31\nSchriften\nabout func.call method:\nGreat question! The .call() method is used in JavaScript to invoke a function with a specific value for this. Let\u2019s break it down:\n\nin generall when we call the someFunction without call method, the this reffers to window, but now:\n\nfunction someFunction() {\nconsole.log(this);\n}\n\nsomeFunction.call(\'kosher\'); //log kosher\n\nfunction createWrapper() {\nreturn {\ninnerObj: {\ngetThis: () => this, // `this` comes from createWrapper\'s `this`\n},\n};\n}\n\nconst obj1 = createWrapper();\nconsole.log(obj1.innerObj.getThis()); // `this` depends on how createWrapper() was called\n\nconst obj2 = createWrapper.call({ custom: "I\'m the wrapper this" });\nconsole.log(obj2.innerObj.getThis()); // { custom: "I\'m the wrapper this" }\n26 February 2025\n00:56\nSchriften\nAbout access and refresh tokens:\n\nAccess tokens are short lived (15 min) , it saved in cookies on header and sends in each req to server. When this token is expired, front send automatically the saved refresh token to the back, after its verified, back send a new access tokens. This way no logging out happens and user can be verified.\n\nTokens are saved in http only req and therefor JavaScript can not have access to it.\n01:04\n//Backend setting cookies in client browser:\n\nres.cookie("accessToken", accessToken,\n{ httpOnly: true, secure: true, sameSite: "strict" });\nres.cookie("refreshToken", refreshToken, { httpOnly: true, secure: true, sameSite: "strict" });\n\nhttpOnly: true (Most Important Security Setting)\nPrevents JavaScript access to the cookie.\nStops XSS attacks from stealing the token.\nThe cookie can only be accessed by the server (not localStorage or sessionStorage)\n\nsecure: true\nThe cookie is only sent over HTTPS.\nPrevents attacks on unsecured (HTTP) connections.\nImportant in production (but must be turned off for local development if not using HTTPS).\n\nsameSite: "strict"\nPrevents CSRF (Cross-Site Request Forgery) attacks.\nEnsures cookies are only sent from the same site (not from external websites).\n"strict" means the cookie is never sent when navigating from another site (high security).\nIf "lax", it would allow cookies in safe cross-site requests (e.g., links).\n01:10\nconst response = await axios.get("http://localhost:5000/protected", { withCredentials: true });\n\nThe { withCredentials: true } option ensures cookies are included in the request and response.\nThe backend validates the credentials, generates JWT tokens, and sends them as HTTP-only cookies.\nThe browser automatically saves the cookies for future requests.\n20:36\nSchriften\nhandling http req in react vite:\nwe can use axios because:\n\n- Supports interceptors: we can set rules and handle diff situation of res or req with it. we can get token from req and presve it for future use ( if token is not in cookies and not http-only)\n- we can retry req automatically when its rejected\n\nconst apiClient = axios.create({\nbaseURL: "https://api.example.com", // Replace with your API URL\nwithCredentials: true, // Sends cookies (for authentication)\nheaders: {\n"Content-Type": "application/json",\n},\n});\n\n// Request Interceptor (Adds Authorization Token)\napiClient.interceptors.request.use(\n(config) => {\nconst token = localStorage.getItem("accessToken");\nif (token) {\nconfig.headers.Authorization = `Bearer ${token}`;\n}\nreturn config;\n},\n(error) => {\nreturn Promise.reject(error);\n}\n);\n\napiClient.interceptors.response.use(\n(response) => response, // Success response\nasync (error) => {\nconst originalRequest = error.config;\nif (error.response?.status === 401 && !originalRequest.\\_retry) {\noriginalRequest.\\_retry = true;\ntry {\nconst { data } = await axios.post(\n"https://api.example.com/auth/refresh-token",\n{},\n{ withCredentials: true }\n);\nlocalStorage.setItem("accessToken", data.accessToken);\napiClient.defaults.headers.Authorization = `Bearer ${data.accessToken}`;\nreturn apiClient(originalRequest); // Retry the failed request\n} catch (refreshError) {\nconsole.error("Session expired. Please log in again.");\n}\n}\nreturn Promise.reject(error);\n}\n);\n\n, automatic request cancellation, and better error handling.\n20:40\nalse in handling http req we can use react query to cash responces. this way we dont need to req every time we back to previos page:\n\nconst fetchUser = async () => {\nconst { data } = await apiClient.get("/user/profile");\nreturn data;\n};\n\nexport const useUser = () => {\nreturn useQuery({\nqueryKey: ["user"],\nqueryFn: fetchUser,\nstaleTime: 1000 _ 60 _ 5, // Cache for 5 minutes\n});\n};\n20:55\nwe can alose use SWR instead react query but react query is more advanced and more configurable:\nRQ has optimisitc updates and retry but SWR is much simpler.\n\nwith retry we can retry any req by error types or any condition. by defualt any faild req in RQ will retry 3 times:\n\nexport const useUser = () => {\nreturn useQuery(["user"], () => apiClient.get("/user").then((res) => res.data), {\nretry: (failureCount, error) => {\nif (error.response?.status >= 400 && error.response?.status < 500) {\nreturn false; // Don\'t retry on client errors (4xx)\n}\nreturn failureCount < 3; // Retry up to 3 times for other errors\n},\n});\n};\n\nwith optimisic update we can update UI before any resopoce comming from server optimictically.\nRQ has a mutate methot to handle that and if the req is failed we can also roll back to prev state.\n\nimport { useMutation, useQueryClient } from "@tanstack/react-query";\nimport apiClient from "../api/apiClient"; // Axios instance\n\nexport const useUpdatePost = () => {\nconst queryClient = useQueryClient();\n\nreturn useMutation(\n(updatedPost) => apiClient.put(`/posts/${updatedPost.id}`, updatedPost),\n{\n// \u2705 Optimistic Update\nonMutate: async (updatedPost) => {\nawait queryClient.cancelQueries(["post", updatedPost.id]);\n\n        const previousPost = queryClient.getQueryData(["post", updatedPost.id]);\n\n        // Update UI immediately\n        queryClient.setQueryData(["post", updatedPost.id], (oldPost) => ({\n          ...oldPost,\n          title: updatedPost.title,\n        }));\n\n        return { previousPost };\n      },\n\n      // \u2705 Rollback if Error Occurs\n      onError: (error, updatedPost, context) => {\n        queryClient.setQueryData(["post", updatedPost.id], context.previousPost);\n      },\n\n      // \u2705 Refetch Data from Server After Success\n      onSettled: (updatedPost) => {\n        queryClient.invalidateQueries(["post", updatedPost.id]);\n      },\n    }\n\n);\n};\n20:57\nSWR does not have a built-in onMutate like React Query, but you can achieve optimistic updates manually using mutate()\n\nexport const updatePostTitle = async (postId, newTitle) => {\nconst updatedPost = { id: postId, title: newTitle };\n\n// \u2705 Optimistically update the cache\nmutate(`/posts/${postId}`, (prevData) => ({ ...prevData, title: newTitle }), false);\n\ntry {\nawait apiClient.put(`/posts/${postId}`, updatedPost);\nmutate(`/posts/${postId}`); // \u2705 Revalidate after success\n} catch (error) {\nmutate(`/posts/${postId}`); // \u274c Rollback on failure\nthrow error;\n}\n};\n20:59\nYou can customize retry behavior using errorRetryCount and errorRetryInterval in SWR\nIt does NOT retry POST, PUT, DELETE mutations (React Query supports this).\n28 February 2025\n13:06\nSchriften\nabout import.meta.glob(dir)\n\nreact vite allows use to impotrt multiple modules from the fileSysyem:\n\nconst pages = import.meta.glob(\'@/pages/\\*_/_.tsx\', { eager: true });\n\n// by default vite lazyload the paths if the eager true is NOT set\n// remember when lazyload is on, all the module in a dir will be importer and tree shakinh is not happen.\n\nthis gives use an obj with path name as key and module as value. we can map throght this obj to get paths and modules.\n\nIt\'s possible to only import parts of the modules with the import options.\n\nconst modules = import.meta.glob(\'./dir/\\*.js\', { import: \'setup\' })\n\n//When combined with eager it\'s even possible to have tree-shaking enabled for those modules.\nconst modules = import.meta.glob(\'./dir/\\*.js\', {\nimport: \'setup\',\neager: true,\n})\n13:18\nlazyLoading and eagerLoading:\nin lazy files will imported when they\'re needed (reducing init bundle). but in eagerLoading files are imported imidiatly in build time.\nin vite when we lazyload\n\nconst pages = import.meta.glob(\'@/pages/\\*_/_.tsx\')\n\nthe value of the pages obj is a func that returns a promise and if we want to use that module we have to get it in .then ie import them manually.\n\nsetting eager to true for mediuom app is okay but as the app grows its better to lazyload to reduce the required code for initial page.\nbut rememer if You want instant navigation between all pages the eagerLoading might help.\n3 March 2025\n22:50\nSchriften\nabout recursive or simple loop func performance:\n\n//recursive\nfunction sumRecursive(n) {\nif (n === 0) return 0;\nreturn n + sumRecursive(n - 1);\n}\n\n//itarative approach:\n\nfunction sumIterative(n) {\nlet sum = 0;\nfor (let i = 1; i <= n; i++) {\nsum += i;\n}\nreturn sum;\n}\n\nthe recursive way and itarative way both have same TC - o(n) but the recursive has more SC: it is o(n) but the itarative has o(1)\nso generally iterative way has better in performance due to the less space complexity and dont need any stack managemenet.\nso\n\n- itarative way uses a fixed amount of memory (usually O(1)\n- recursive way can lead to stack overflow if the recursion depth is too large.\n- The time complexity of recursive remains the same as the iterative version if implemented correctly, but space complexity might increase due to stack frames.\n  6 March 2025\n  19:10\n  Schriften\n  about stack and queue:\n\nstack is first in last out and used inside functuin call stack, browser history, recursion.\n\nfunction first() {\nconsole.log("First function called");\nsecond();\nconsole.log("First function finished");\n}\n\nfunction second() {\nconsole.log("Second function called");\nthird();\nconsole.log("Second function finished");\n}\n\nfunction third() {\nconsole.log("Third function called");\n}\n\nfirst();\n// - first push to callstack, then second and then third, after execution of the third, the second func execution continues from the rest and the funcs popped off from last to start.\n// First function called, sec function called, third function called, after this, js backtracks to pop off prev func from the stack and:\n\n//sec function finishid, First function finished\n\nqueue is first in first out and used in request handling\n10 March 2025\n22:33\nSchriften\n\n- arr.find has o(n) tc and use simpleSeaarch\n- arr.sort has o(n log n ) tc in avarage cases and worst cases and o(n) when the list is already sorted!\n  arr.sort uses timeSort in modern JavaScript engines v8 (e.g., Chrome, Node.js, Edge, Firefox) and in older uses quickSort.\n  Timsort is a hybrid algorithm combining Merge Sort and Insertion Sort.\n  24 March 2025\n  16:12\n  Schriften\n  document.startViewTransition simple explain:\n  it takes a snapshot from the page current state and then runs dom updated (ui changes or route changes ...) and then it animate between the snapshop and the new dom update.\n  we can customize the default behavior of the viewTransition animation wit setting the css related prop:\n\n/_ Create a custom animation _/\n\n@keyframes move-out {\nfrom {\ntransform: translateY(0%);\n}\n\nto {\ntransform: translateY(-100%);\n}\n}\n\n@keyframes move-in {\nfrom {\ntransform: translateY(100%);\n}\n\nto {\ntransform: translateY(0%);\n}\n}\n\n/_ Apply the custom animation to the old and new page states _/\n\n::view-transition-old(root) {\nanimation: 0.4s ease-in both move-out;\n}\n\n::view-transition-new(root) {\nanimation: 0.4s ease-in both move-in;\n}\n16:33\nSchriften\nstartViewTransition returns a promise with 2 methods: .ready:\nthis is called when the new state applies and before any animation happens.\n\nfinished resolves when the animation is completely done.\n23:35\nSchriften\nhow timeSort works:\nits a combination of mergeSort and selection sort. it turns the array in to smaller chunks or subArray and sort inside these subArrays with selectionSort and then merge all these array with mergeSort. TC of this algo is:\n\n- in worst case (already sorted arr) = o(n)\n- avarage case o (n log n)\n- best case o(n log n)\n  28 March 2025\n  18:12\n  Schriften\n  why using simple variables for storing data in react doesn\'t work:\n  Because React components are just functions, normal variables won\u2019t persist across different invocations of those functions (which React calls renders).\n  3 May 2025\n  12:51\n  Schriften\n  Docker for front end.pdf\n  Not included, change data exporting settings to download.\n  2.7 MB\n  Docker for front end.pdf\n  7 May 2025\n  21:25\n  Schriften\n  reduce bundle size:\n  code spliting:\n  useing react.lazy to load compoenend when needed (on demand) and not in build time at the init js bundle. react lazy comp loaded at render time.\n  lazyloading improves faster initial load => TTI use can start interacting much sooner.\n  les memory usage. cause the browser doesnt need to hold all the parsed js at once.\n  lazy loading pages can also be a very good idea to reduce bundle size.\n\ntree shaking:\nenure the install libs support ESM and avoid common js. cause commonJS doent tree shaked and also does not support lazyLoading.\n\nremoving dead code : with bundle analyzer we can watch moudles that are inclueded in the bundle but never have been used.\nsetting sideEffect: false in the lib in pacck.json: when you verified that the module hasn\'t anyside affects, with setting this you help module bundler to be sure it can treeshake the lib if needed.\n\nuseing lighter alternative libs: keenslider instread swiper or nanoId instead uuid.\n\nuse svg and svg optimize\n\nssr + partial hydration: old ssr caused issues in page transtion because the page need be fully rendered on server by navigating\nbut with hydration only part of the page could be ssred and the rest be fetched on the client side. ( we could use react.layzy to make thesse parts be fetched on client)\n8 May 2025\n14:36\nSchriften\nIn reply to this message\nreact disable event pooling from 17th version. the pooling makes the handler unsutable for async tasks like async/await or setTimeout. cause the event object properties set to null and cleare after the event handler is compeleted. so now we have an synthetic event obj instance for every event we trigger. we can now have access to event properties asynchronly without needing to call event.persist()\n17:39\nSchriften\nnew Event and new CustomEvent\nnew Event() in browser is for creating a basic custom Event object. its very simple doesn\'t support payload and its for transfering simple singals.\ninstead the CustomEvent supports payload and more complicated structure.\nwe can use both of them in EventTarget.dispatchEvent.\n\nconst event = new Event("my-event");\n\nelement.dispatchEvent(event);\n17:54\nSchriften\nMohsen Khademhoseini 08.05.2025 17:54:08\n10_Code_Challenges_to_Master_Promise_then_and_Promise_catch_by_Shuai.pdf\nNot included, change data exporting settings to download.\n1.6 MB\n17:54\n10_JavaScript_Promise_Challenges_Before_You_Start_an_Interview_by.pdf\nNot included, change data exporting settings to download.\n4.7 MB\n23:11\nSchriften\nPhoto\nNot included, change data exporting settings to download.\n1280\xd7618, 56.8 KB\n.catch in promise also returns a new promise which allows that any .then after it be executed.\n23:15\nPhoto\nNot included, change data exporting settings to download.\n1280\xd7649, 40.5 KB\nin fact .then and .catch botch return a promise and tranfers the last return value to the other chained .then or .catch\n23:23\nconst promise = new Promise((resolve, reject) => {\nresolve(1);\n});\n\npromise.then(res => {\nconsole.log(\'first then: \', res);\nreturn 2;\n});\n\npromise.then(res => {\nconsole.log(\'second then: \', res);\nreturn 3;\n});\n\npromise.then(res => {\nconsole.log(\'third then: \', res);\n});\n\n// log resut: 1 - 1 - 1\n\nconst promise = new Promise((resolve, reject) => {\nresolve(1);\n});\n\npromise\n.then(res => {\nconsole.log(\'first then:\', res); // res = 1\nreturn 2;\n})\n.then(res => {\nconsole.log(\'second then:\', res); // res = 2\nreturn 3;\n})\n.then(res => {\nconsole.log(\'third then:\', res); // res = 3\n});\n// log result: 1 - 2 - 3\n9 May 2025\n17:06\nSchriften\nabout mono repo:\nwhen we\'re using a system which handles different projects in a single repository.\n\n- with mono repo all projects stays always sync and updated\n- it makes upadate and changes faster ( all projects will changed with one commt!)\n- mono repo project could access a very highly valued resources of other projects like utils and logic, basic comps, bakend api and libs.\n- tools like Nx or turborepo help to manage mono repo\n- in mono repo, safty is very important! staging env, code review, test-writing - storybook or...\n\ndownsides:\n\n- lower build time, lowr CI and CD time (google built its own tool for handle build time called Bazel to deal with massive scale builds)\n- tools like npm or git or webpack struggle with mono repos and companies should create custom tool or use open source tools like lerna\n- harder and long onboarding for new one - so documentation is veeeery imortant\n  17:36\n  Schriften\n  about lerna\n  js/ts mono repos could use lerna. lerna is an open-source package manger with that we can link local packages acrros different prject without needing to insall them speparately. it manges also versioning\n  11 May 2025\n  20:35\n  Schriften\n  about stacking context\n  its a layering system that determine how the elements should be layered related to each other.\n  or:\n  stacking context determins the order in which the html elements are positioned. buy default the order is:\n  root element\n  non positioned element\n  positioned element\n\nby default every element should obay the root stacking context (html) but when some css prop is set inside an element, a new stacking context is created by that element.\ngiving zIndex to an element create a new stacking context.\nelement that are positioned create their own stacking context, child elements insdie them onbay that statcking context but chaning z-index of that child doesn\'t affect the ohter element outside its parent, cause the outsiders have their own stacking context (it might be the root by default)\n\nisolation:isolate prop\nit can be used to create stacking context for an element without postioning it.\nwhen we have an element with z-999 it might accidently apear on top of something that we dont want to, isolating it (or it parent) allows us to force that element to stay inside its stacking context\n\nprops like filter, opacity, transform, isolation can also create stacking context\n\nhttps://www.geeksforgeeks.org/describe-z-index-and-how-a-stacking-context-is-formed-in-css/\n12 May 2025\n22:28\nSchriften\nin other words with z-index we can explicitly control the stacking order of html elements.\n\nBy default, a plain HTML document will have a single stacking context that encompasses all nodes. But we can create additional contexts!\n\nAn element inside one stacking context can never be compared against elements in another:\nAccording to the rules of CSS, there is no way for us to "break free" of the stacking context. An element inside one stacking context can never be compared against elements in another.\nWe can still achieve the desired result, however, with a bit of out-of-the-box\\* thinking.\n(means we bring tooltip out of the main) we could do such thing in react bt creating portal.\n\nWhen a stacking context is created, it \u201cflattens\u201d all of its descendants. Those children can still be rearranged internally, but we\'ve essentially locked those children in\n\nAbout isolation:\nWhen we apply this declaration to an element, it does precisely 1 thing: it creates a new stacking context.\n\nWith so many different ways to create a stacking context, why do we need another one? Well, with every other method, stacking contexts are created implicitly, as the result of some other change. isolation creates a stacking context in the purest way possible: don\'t need pos zindex, filter, flex zindex and....\n13 May 2025\n20:17\nSchriften\nDiff merge and rebase\nIn merge the history will not be rewritten, it takes all next the steps of the main and merges with the feat branch that created from two steps before of the main and add a new commit for this.\n\nRebase take the whole branch and move it on top of the main branch like the whole commits belong to the main from first.\n22:47\nSchriften\nAbout execution context:\nThe Env that js codes run and execute\n\nThree kinds of context:\nglobal context (window or global in node)\nfunctional context\nEval context\n\nIt has two phases:\nCreation: memory allocation and hosting happen here\n\nExecution phase: executing codes line by line, assigning value to variables, executing funcs\n\nMemory allocation in first phase:\nJs reserve memory for variables and then assign the real value in sec phase.\n18 May 2025\n00:05\nSchriften\nabout commonJs and tree shaking:\nif we require and use commonJs to use a file, tree shaking will not happen. because tree shaking needs to know statically which file or data is exported (its based on static analysis ) and in commomJs the require will imports the enitre module.\n00:06\nalso we cant dynamically import a commonJs module unless we make it as default export and its again a bad practice. but in a native ESM env we cant that at all undless we use createRequire()\n00:09\nHow ISR Works (Simplified)\nOn build, Next.js statically generates pages using getStaticProps.\n\nWhen a user visits a page:\n\nIf the static page exists and is fresh \u2192 it\'s served instantly.\n\nIf it\u2019s stale (based on revalidate time), a background regeneration is triggered.\n\nThe updated page is saved and served for future requests.\n\n// pages/blog/[slug].js\n\nexport async function getStaticProps(context) {\nconst post = await fetchPost(context.params.slug);\n\nreturn {\nprops: { post },\nrevalidate: 60, // Re-generate the page **every 60 seconds**\n};\n}\n27 May 2025\n09:38\nSchriften\nAbout docker and dockerize:\n\nDocker creates a consistent environment \u2014 it doesn\u2019t care about the developer\u2019s local setup.\n09:40\nIt keeps the node version of the app stable and ensures that the app runs in a stable and safe env.\n09:41\nAlso it is a great way for batching up the client and server side of the app and running them together locally.\nFor the we set image ports and image in the\ndocker-compose.yml file and run docker compose.\n31 May 2025\n20:43\nSchriften\nabout loading css in react vite\nin development:\nreact load all .css and module.css files in the head section inside style tags. this is render blocking but this adding gives react HMR in css codes. so react serves them as ESM and inject the style tags dynamically without bundling.\n\nin production mode:\nreact vite use rollup to bundle everything even css module or tw , it minified them, cached them and store them inside a global index-hash.css file and link it inisde a link tap on top of the project with stylesheet rel.\nthis index-hash.css is created inside dist and it changes everytime a new style is added or changed so the ui could tell something changed and update it self.\n\nTWIST: by default there is always one index.css in production after build but it could be more when we lazyloaded some comp.\nwhen such comp loaded and has some styling, the style will be add in a different index-hash.css file and be linked on top.\n4 June 2025\n02:12\nSchriften\nBuilding.Micro-Frontendsr.pdf\nNot included, change data exporting settings to download.\n9.0 MB\n7 June 2025\n21:53\nSchriften\nAbout stack and heap:\n\nStack is for storing short-lived data: func calls and funcs local variable (str number)\nA func be called and then popped of from stack, if too many func calls happens without popping of from stack (recursions) we face max call stack err.\nThis error happens after browser or node reach their call stack limit.\nIn chrome or node is between 10000 to 20000 call. The max is based on how much ram is in use.\n\nHeap is for storing complex data like funcs, obj and arr or long or dynamic str. The data stored in heap will be removed by GC.\nIf a func has an obj and returns it and then we call func and assign it to the variable, the data will remain in heap if not, the data will be GCed.\nHeap is for storing long-lived and complex data and is bigger that stack\n'})})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(6540);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);